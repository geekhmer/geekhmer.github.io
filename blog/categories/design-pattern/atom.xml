<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design Pattern | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/design-pattern/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-02-04T16:48:52+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Decorator Design Pattern]]></title>
    <link href="http://geekhmer.github.io/blog/2014/07/22/decorator-design-pattern/"/>
    <updated>2014-07-22T20:10:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/07/22/decorator-design-pattern</id>
    <content type="html"><![CDATA[<p>
  In the object-oriented world, simple applications usually require small classes with static behaviors. Adding, modifying, and sharing those behaviors can be achieved by mixing in modules or inheriting from other classes at compile time.
</p>




<p>
  However, more complex applications might require a particular instance of a class to gain additional functionality at runtime. To modify the behavior of an object dynamically, we can utilize the decorator design pattern.
</p>




<p>
  <strong>When to Decorate</strong><br/>
  Decoration can be used to add behavior to any individual object without affecting the behavior of other objects of the same class. Essentially the existing object is being wrapped with additional functionality. 
</p>




<p>
  <strong>Some practical problems that can be solved by decoration are</strong><br/>
  - applying one or more UI elements to a specific UI widget at runtime.<br/>
  - saving an ActiveRecord model in various ways based on conditionals in a Rails controller.<br/>
  - adding additional information to data streams by pre/appending with additional stream data.
</p>




<p>
  <strong>Implementations of Decorators in Ruby</strong><br/>
  There are several ways to implement the decorator pattern in Ruby, but I cover my 4 favorite ways:<br/>
  - Class + Method Missing decorator<br/>
  - Module + Extend + Super decorator<br/>
  - Plain Old Ruby Object decorator<br/>
  - SimpleDelegator + Super + Getobj decorator
</p>




<p>
  <strong>Class + Method Missing Decorator</strong><br/>
  The benefits of this implementation are:<br/>
  - can be wrapped infinitely using Ruby instantiation.<br/>
  - delegates through all decorators.<br/>
  - can use the same decorator more than once on the same component.<br/>
  - transparently uses component's original interface.
</p>




<p>
  The drawbacks of this implementation are:<br/>
  - uses method_missing.<br/>
  - the class of the decorated object is the decorator.
</p>




<p>
  Sample example
</p>


<p>{% codeblock sample.rb lang:ruby %}
module Decorator
  def initialize(decorated)</p>

<pre><code>@decorated = decorated
</code></pre>

<p>  end</p>

<p>  def method_missing(meth, *args)</p>

<pre><code>if @decorated.respond_to?(meth)
  @decorated.send(meth, *args)
else
  super
end
</code></pre>

<p>  end</p>

<p>  def respond_to?(meth)</p>

<pre><code>@decorated.respond_to?(meth)
</code></pre>

<p>  end
end</p>

<p>class Coffee
  def cost</p>

<pre><code>2
</code></pre>

<p>  end
end</p>

<p>class Milk
  include Decorator</p>

<p>  def cost</p>

<pre><code>@decorated.cost + 0.4
</code></pre>

<p>  end
end</p>

<p>class Whip
  include Decorator</p>

<p>  def cost</p>

<pre><code>@decorated.cost + 0.2
</code></pre>

<p>  end
end</p>

<p>class Sprinkles
  include Decorator</p>

<p>  def cost</p>

<pre><code>@decorated.cost + 0.3
</code></pre>

<p>  end
end</p>

<p>Whip.new(Coffee.new).cost #=> 2.2
Sprinkles.new(Whip.new(Milk.new(Coffee.new))).cost #=> 2.9</p>

<h1>Factory class</h1>

<p>class CoffeeFactory
  def self.cappuccino</p>

<pre><code>Sprinkles.new(Cream.new(Milk.new(Coffee.new)))
</code></pre>

<p>  end
end</p>

<p>CoffeeFactory.cappucino.kind_of? Coffee #=> true
{% endcodeblock %}</p>

<p>
  <strong>Module + Extend + Super Decorator</strong><br/>
  The benefits of this implementation are:<br/>
  - it delegates through all decorators.<br/>
  - has all of the original interface because it is the original object.
</p>




<p>
  The drawbacks of this implementation are:<br/>
  - can not use the same decorator more than once on the same object.<br/>
  - difficult to tell which decorator added the functionality.
</p>




<p>
  Sample example
</p>


<p>{% codeblock sample.rb lang:ruby %}
class Coffee
  def cost</p>

<pre><code>2
</code></pre>

<p>  end
end</p>

<p>module Milk
  def cost</p>

<pre><code>super + 0.4
</code></pre>

<p>  end
end</p>

<p>module Sugar
  def cost</p>

<pre><code>super + 0.2
</code></pre>

<p>  end
end</p>

<p>coffee = Coffee.new
coffee.extend(Milk)
coffee.cost   #=> 2.4
coffee.extend(Sugar)
coffee.cost   #=> 2.6
{% endcodeblock %}</p>

<p>
  <strong>Plain Old Ruby Object Decorator</strong><br/>
  The benefits of this implementation are:<br/>
  - can be wrapped infinitely using Ruby instantiation.<br/>
  - delegates through all decorators.<br/>
  - can use same decorator more than once on component.
</p>




<p>
  The drawbacks of this implementation are:<br/>
  - cannot transparently use component's original interface.
</p>




<p>
  Sample example
</p>


<p>{% codeblock sample.rb lang:ruby %}
class Coffee
  def cost</p>

<pre><code>2
</code></pre>

<p>  end</p>

<p>  def origin</p>

<pre><code>"Cambodia"
</code></pre>

<p>  end
end</p>

<p>class Sugar
  def initialize(component)</p>

<pre><code>@component = component
</code></pre>

<p>  end</p>

<p>  def cost</p>

<pre><code>@component.cost + 0.2
</code></pre>

<p>  end
end</p>

<p>class Milk
  def initialize(component)</p>

<pre><code>@component = component
</code></pre>

<p>  end</p>

<p>  def cost</p>

<pre><code>@component.cost + 0.4
</code></pre>

<p>  end
end</p>

<p>coffee = Coffee.new
Sugar.new(Milk.new(coffee)).cost  #=> 2.6
Sugar.new(Sugar.new(coffee)).cost #=> 2.4
Sugar.new(Milk.new(coffee)).class #=> Sugar
Milk.new(coffee).origin           #=> NoMethodError
{% endcodeblock %}</p>

<p>
  <strong>SimpleDelegator + Super + Getobj</strong><br/>
  The benefits of this implementation are:<br/>
  - can be wrapped infinitely using Ruby instantiation.<br/>
  - delegates through all decorators.<br/>
  - can use same decorator more than once on component.<br/>
  - transparently uses component's original interface.<br/>
  - class if the component.
</p>




<p>
  The drawbacks of this implementation are:<br/>
  - it redefines class.
</p>




<p>
  Sample example
</p>


<p>{% codeblock sample.rb lang:ruby %}
class Coffee
  def cost</p>

<pre><code>2
</code></pre>

<p>  end</p>

<p>  def origin</p>

<pre><code>'Cambodia'
</code></pre>

<p>  end
end</p>

<p>require &lsquo;delegate&rsquo;</p>

<p>class Decorator &lt; SimpleDelegator
  def class</p>

<pre><code>__getobj__.class
</code></pre>

<p>  end
end</p>

<p>class Milk &lt; Decorator
  def cost</p>

<pre><code>super + 0.4
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  So far so good, Let decorate your way with Decorator Design Pattern. :)
</p>

]]></content>
  </entry>
  
</feed>
