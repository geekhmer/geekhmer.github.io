<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Gulp | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/gulp/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-10-11T20:46:21+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gulp – Validate JavaScript]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/11/gulp-validate-javascript/"/>
    <updated>2016-10-11T11:42:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/11/gulp-validate-javascript</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/bunlong_gulp.jpg" width="600" alt="Gulp, Gulp – Validate JavaScript" />
</p>




<p>
  The web runs on more than HTML and CSS, It runs on JavaScript. Let’s perform some common JavaScript build operations with gulp.
</p>




<p>
  We will first look into validating our JavaScript using gulp.
</p>




<p>
  And yes... there is a plugin for that.
</p>


<p>{% codeblock lang:ruby %}
$ npm install gulp-jsvalidate &mdash;save-dev
{% endcodeblock %}</p>

<p>
  For more information on <code>gulp-jsvalidate</code> check out <a href="https://github.com/sindresorhus/gulp-jsvalidate" target="_blank">https://github.com/sindresorhus/gulp-jsvalidate</a>.
</p>




<p>
  We will now create a new Javascript task in our <code>gulpfile.js</code>. At first, all we will do is validate our Javascript in a new <code>/contents/javascripts</code> folder.
</p>


<p>{% codeblock /gulpfile.js lang:ruby %}
&hellip;
var jsValidate = require(&lsquo;gulp-jsvalidate&rsquo;);
&hellip;</p>

<p>&hellip;
gulp.task(&lsquo;javascript&rsquo;, function () {
  console.log(&ldquo;Validate JavaScript&rdquo;);
  return gulp.src(&ldquo;contents/javascripts/**.js&rdquo;)</p>

<pre><code>.pipe(jsValidate());
</code></pre>

<p>});
&hellip;
{% endcodeblock %}</p>

<p>
  Time to test out our new task and plugin. Create a javascript file and make a syntax error.
</p>


<p>{% codeblock /contents/javascript/somejs.js lang:ruby %}
function OMG() {
  var x * 2; // this is not valid!
  return x + 10;
}
{% endcodeblock %}</p>

<p>
  Now when we run our javascript task, we will get an error message in the terminator:
</p>


<p>{% codeblock lang:ruby %}
$ gulp javascript</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpfile.js
Starting &lsquo;javascript&rsquo;&hellip;
&lsquo;javascript&rsquo; errored after 14 ms Line 3: Unexpected token *
{% endcodeblock %}</p>

<p>
  When we fix the error and then run our gulp task, we won’t get that error message:
</p>


<p>{% codeblock /contents/javascript/somejs.js lang:ruby %}
function OMG() {
  var x = 2;
  return x + 10;
}
{% endcodeblock %}</p>

<p>{% codeblock lang:ruby %}
$ gulp javascript</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpfile.js
Starting &lsquo;javascript&rsquo;&hellip;
Validate JavaScript
Finished &lsquo;javascript&rsquo; after 14 ms
{% endcodeblock %}</p>

<p>
  Sweet codes! Gulp can now check if our JavaScript is valid. But the error message in the console is rather bland, lets find a better way to tell us that we messed up.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulp – Handling Errors with Streams]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/10/gulp-handling-errors-with-streams/"/>
    <updated>2016-10-10T22:08:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/10/gulp-handling-errors-with-streams</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/gulpjs.jpg" width="600" alt="Gulp, Gulp – Handling Errors with Streams" />
</p>




<p>
  What if the file was named incorrectly? What happens?
</p>




<p>
  Change the string <code>index.html</code> to <code>OMG_WRONG_FILE.html</code> and rerun the script.
</p>


<p>{% codeblock /streams.js lang:ruby %}
var fs = require(&ldquo;fs&rdquo;);
var stream = fs.createReadStream(__dirname + &ldquo;/contents/OMG_WRONG_FILE.html&rdquo;);</p>

<p>stream.on(&ldquo;data&rdquo;, function(chunk) {
  // just output chunk to terminal
  console.log(chunk.toString());
});</p>

<p>stream.on(&ldquo;end&rdquo;, function() {
  console.log(&ldquo;END&rdquo;);
});
{% endcodeblock %}</p>

<p>
  Running the script this time results in:
</p>


<p>{% codeblock lang:ruby %}
$ node streams.js</p>

<p>events.js:72</p>

<pre><code>    throw er; // Unhandled 'error' event
</code></pre>

<p>Error: ENOENT, open &lsquo;~/YOUR_DIRECTORY/OMG_WRONG_FILE.html&rsquo;
{% endcodeblock %}</p>

<p>
  If we read the error message carefully, then we can see that there is an error event we can listen to. So lets listen for that event.
</p>


<p>{% codeblock /streams.js lang:ruby %}
&hellip;
stream.on(&ldquo;error&rdquo;, function(er) {
  console.log(&ldquo;error&rdquo;, er);
});
{% endcodeblock %}</p>

<p>
  Now we rerun the script and see:
</p>


<p>{% codeblock lang:ruby %}
$ node streams.js</p>

<p>error { [Error: ENOENT, open &lsquo;/Users/bunlong/js/gulp/contents/OMG_WRONG_FILE.html&rsquo;]
  errno: -2,
  code: &lsquo;ENOENT&rsquo;,
  path: &lsquo;~/YOUR_DIRECTORY/contents/OMG_WRONG_FILE.html&rsquo; }
{% endcodeblock %}</p>

<p>
  And that is it for now. We will come back and use some of what we learned later.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulp – Streams]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/04/gulp-streams/"/>
    <updated>2016-10-04T09:18:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/04/gulp-streams</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/gulpjs.jpg" width="600" alt="Gulp, Gulp – Minify Our CSS" />
</p>




<p>
  Before we continue, I think a brief detour to cover some basics of Node streams would be helpful.
</p>




<p>
  Lets create a simple Node script to read a <code>index.html</code> file we will create:
</p>


<p>{% codeblock /contents/index.html lang:ruby %}
&lt;!DOCTYPE html>
<html>
<head>
  <title>Learning Gulp</title>
</head>
<body>
  <h1>Hello Gulp!</h1>
</body>
</html>
{% endcodeblock %}</p>

<p>
  First we require the file system library <code>fs</code> and create a read stream.
</p>


<p>{% codeblock /streams.js lang:ruby %}
var fs = require(&ldquo;fs&rdquo;);
var stream = fs.createReadStream(__dirname + &ldquo;/contents/index.html&rdquo;);
{% endcodeblock %}</p>

<p>
  <code>_dirname</code> is a helper that returns the absolute path of the code file being run.
</p>




<p>
  Node reads files asynchronously. This is normally where we could dive into what "non-blocking I/O" means vs threads, etc. This is a guide about gulp though so I will keep this detour basic.
</p>




<p>
  For our purposes, this means that we have to listen to <strong>events</strong> from the stream to be able to read the file.
</p>




<p>
  The events we are going to listen to are <code>data</code> and <code>end</code>.
</p>




<p>
  <code>data</code> fires when a chunk of the file has been read and returned. <strong>This chunk is not always the entire file</strong>. In fact, you should assume it is not the entire file.
</p>


<p>{% codeblock /streams.js lang:ruby %}
&hellip;
stream.on(&ldquo;data&rdquo;, function(chunk) {
  // just output chunk to terminal
  console.log(chunk.toString());
});
{% endcodeblock %}</p>

<p>
  <code>end</code> fires when the file has been completly read.
</p>


<p>{% codeblock /streams.js lang:ruby %}
&hellip;
stream.on(&ldquo;data&rdquo;, function(chunk) {
  // just output chunk to terminal
  console.log(chunk.toString());
});
{% endcodeblock %}</p>

<p>
  Now altogether, <code>streams.js</code> looks like:
</p>


<p>{% codeblock /streams.js lang:ruby %}
var fs = require(&ldquo;fs&rdquo;);
var stream = fs.createReadStream(__dirname + &ldquo;/contents/index.html&rdquo;);</p>

<p>stream.on(&ldquo;data&rdquo;, function(chunk) {
  console.log(chunk.toString());
});</p>

<p>stream.on(&ldquo;end&rdquo;, function() {
  console.log(&ldquo;END&rdquo;);
});
{% endcodeblock %}</p>

<p>
  Now if you run the node script in the terminal, you should see:
</p>


<p>{% codeblock lang:ruby %}
$ node streams.js</p>

<p>&lt;!DOCTYPE html>
<html>
<head>
  <title>Learning Gulp</title>
</head>
<body>
  <h1>Hello Gulp!</h1>
</body>
</html>
END
{% endcodeblock %}</p>

<p>
  So far so good, That’s it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulp – Minify Our CSS]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/03/gulp-minify-our-css/"/>
    <updated>2016-10-03T16:22:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/03/gulp-minify-our-css</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/gulpjs.jpg" width="600" alt="Gulp, Gulp – Minify Our CSS" />
</p>




<p>
  Now since we have our css in a single file, we can continue to increase the performance of our site by minifying our css. 
</p>




<p>
  Minifying is the process of eliminating all the unnecessary formatting in a css file. Human’s need spaces and tabs (also known as white space) to more easily read the styles. A browser doesn’t care about white space so we can make the file smaller by removing them.
</p>




<p>
  You should start seeing a pattern when using gulp... because for this we need to use a plugin:
</p>


<p>{% codeblock lang:ruby %}
$ npm install gulp-minify-css &mdash;save-dev
{% endcodeblock %}</p>

<p>
  For more information on gulp-minify-css, check out <a href="https://www.npmjs.org/package/gulp-minify-css" target="_blank">https://www.npmjs.org/package/gulp-minify-css</a>.
</p>


<p>{% codeblock gulpfile.js lang:ruby %}
var gulp = require(&lsquo;gulp&rsquo;);
var concat = require(&lsquo;gulp-concat&rsquo;);
var clean = require(&lsquo;gulp-rimraf&rsquo;);
var cssmin = require(&ldquo;gulp-minify-css&rdquo;);</p>

<p>gulp.task(&lsquo;clean&rsquo;, [], function() {
  console.log(&ldquo;Clean all files in build folder&rdquo;);</p>

<p>  return gulp.src(&ldquo;build/*&rdquo;, { read: false }).pipe(clean());
});</p>

<p>gulp.task(&lsquo;default&rsquo;, [&lsquo;clean&rsquo;], function() {
  console.log(&ldquo;Concat, move, and minify all the css files in styles folder&rdquo;);
  return gulp.src(&ldquo;contents/styles/**.css&rdquo;)</p>

<pre><code>.pipe(concat('main.min.css'))
.pipe(cssmin())
.pipe(gulp.dest('build/styles'));
</code></pre>

<p>});
{% endcodeblock %}</p>

<p>
  Open up your terminator to run gulp:
</p>


<p>{% codeblock lang:ruby %}
$ gulp</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpFile.js
Starting &lsquo;clean&rsquo;&hellip;
Clean all files in build folder
Finished &lsquo;clean&rsquo; after 18 ms
Starting &lsquo;default&rsquo;&hellip;
Concat, move, and minify all the css files in styles folder
Finished &lsquo;default&rsquo; after 40 ms
{% endcodeblock %}</p>

<p>
  Our <code>build/styles/main.min.css</code> should now look like:
</p>


<p>{% codeblock lang:ruby %}
p{font-size:30px}h1{color:red}
{% endcodeblock %}</p>

<p>
  So far so good, That’s it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulp – Cleaning Our Build Folder]]></title>
    <link href="http://geekhmer.github.io/blog/2016/09/26/gulp-cleaning-our-build-folder/"/>
    <updated>2016-09-26T16:56:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/09/26/gulp-cleaning-our-build-folder</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/gulpjs.jpg" width="600" alt="Gulp, Gulp – Cleaning Our Build Folder" />
</p>




<p>
  A normal part of a build process is a cleaning task to remove all the old files in the build folder.
</p>




<p>
For us, this means getting rid of the leftover <code>more_styles.css</code> and <code>some_styles.css</code> files in our <code>build/styles</code> folder.
</p>




<p>
  To clean files, we will need another gulp plugin:
</p>


<p>{% codeblock lang:ruby %}
$ npm install gulp-rimraf &mdash;save-dev
{% endcodeblock %}</p>

<p>
For more information on gulp-rimraf check out <a href="https://www.npmjs.com/package/gulp-rimraf" target="_blank"> https://www.npmjs.org/package/gulp-rimraf</a>.
</p>




<p>
  This task used to be handled by <code>gulp-clean</code> but has been replaced by <code>gulp-rimraf</code>.
</p>




<p>
Instead of adjusting our <code>default</code> task, lets create a new task to clean out the directory.
</p>


<p>{% codeblock gulpfile.js lang:ruby %}
var gulp = require(&lsquo;gulp&rsquo;);
var concat = require(&lsquo;gulp-concat&rsquo;);
var clean = require(&lsquo;gulp-rimraf&rsquo;);</p>

<p>gulp.task(&lsquo;clean&rsquo;, [], function() {
  console.log(&ldquo;Clean all files in build folder&rdquo;);
  return gulp.src(&ldquo;build/*&rdquo;, { read: false }).pipe(clean());
});</p>

<p>gulp.task(&lsquo;default&rsquo;, [&lsquo;clean&rsquo;], function() {
  console.log(&ldquo;Concating and moving all the css files in styles folder&rdquo;);
  return gulp.src(&ldquo;contents/styles/**.css&rdquo;)</p>

<pre><code>.pipe(concat('main.css'))
.pipe(gulp.dest('build/styles'));
</code></pre>

<p>});
{% endcodeblock %}</p>

<p>
  So like before, we need to require <code>gulp-rimraf</code>.
</p>




<p>
  This time though, we created a new task called <code>clean</code>. We tell this task to look at all the files in the <code>build</code> folder and then pipe them to our clean operation. This will delete the files.
</p>




<p>
  You might notice that in our options we pass in <code>{ read: false }</code>. This tells the task to not read the contents of the files it is deleting. It is an easy performance gain.
</p>




<p>
  To run our clean task from the command line, we just tell gulp which task to run:
</p>


<p>{% codeblock lang:ruby %}
$ gulp clean</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpfile.js
Starting &lsquo;clean&rsquo;&hellip;
Clean all files in build folder
Finished &lsquo;clean&rsquo; after 8.95 ms
{% endcodeblock %}</p>

<p>
  What we would like is to run our <code>clean</code> task before we run our <code>default</code> task. That way our build folder will be nice and empty before we starting moving files there.
</p>




<p>
You might have been wondering what the empty array (<code>[]</code>) was before our <code>function</code>. This is where we specify dependency tasks.
</p>




<p>
  A <strong>dependency task</strong> is a task that needs to be completed before gulp can run the current task.
</p>




<p>
  So for our scenario, our <code>clean</code> task is a dependency for <code>default</code>.
</p>


<p>{% codeblock gulpfile.js lang:ruby %}
&hellip;
gulp.task(&lsquo;default&rsquo;, [&lsquo;clean&rsquo;], function() {
  &hellip;
});
{% endcodeblock %}</p>

<p>
  Now when we run our <code>default</code> gulp task, we should see that it runs the <code>clean</code> task before <code>default</code>.
</p>


<p>{% codeblock lang:ruby %}
$ gulp</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpfile.js
Starting &lsquo;clean&rsquo;&hellip;
Clean all files in build folder
Finished &lsquo;clean&rsquo; after 9.03 ms
Starting &lsquo;default&rsquo;&hellip;
Concating and moving all files from styles folder
Finished &lsquo;default&rsquo; after 8.42 ms
{% endcodeblock %}</p>

<p>
  So far so good, That’s it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
