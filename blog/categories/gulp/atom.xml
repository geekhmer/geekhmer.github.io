<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Gulp | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/gulp/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-10-11T22:11:43+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gulp – Uglify]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/11/gulp-uglify/"/>
    <updated>2016-10-11T22:02:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/11/gulp-uglify</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/bunlong_gulp.jpg" width="600" alt="Gulp, Gulp – Uglify" />
</p>




<p>
  For JavaScript files we also want to uglify them. Uglifying JavaScript involves changing variable and function names to reduce their size. So a variable named customer might be renamed to x. JavaScript engines don’t care about descriptive names, only developers. So how do we uglify JavaScript files with gulp?
</p>




<p>
  I know what you are going to say: "Blah, blah, blah... there is a plugin." and you are correct.
</p>


<p>{% codeblock lang:ruby %}
$ npm install gulp-uglify &mdash;save-dev
{% endcodeblock %}</p>

<p>
  For more information on <code>gulp-uglify</code> check out <a href="https://www.npmjs.org/package/gulp-uglify" target="_blank">https://www.npmjs.org/package/gulp-uglify</a>.
</p>




<p>
  While we are uglifying the file, we will also concat all our JavaScript files together and move them to <code>build/javascripts</code>.
</p>


<p>{% codeblock gulpfile.js lang:ruby %}
&hellip;
var uglify = require(&lsquo;gulp-uglify&rsquo;);
&hellip;</p>

<p>gulp.task(&lsquo;javascript&rsquo;, function () {
  console.log(&ldquo;Validate, Concat, Uglify, and Move all the javascript files&rdquo;);</p>

<p>  return gulp.src(&ldquo;contents/javascripts/**.js&rdquo;)</p>

<pre><code>.pipe(jsValidate())
.on("error", notify.onError(function(error) {
  return error.message;
}))
.pipe(uglify())
.pipe(concat('main.js'))
.pipe(gulp.dest('build/javascripts'));
</code></pre>

<p>});
{% endcodeblock %}</p>

<p>
  When you run our gulp javascript task now, we should see that our javascript files were uglified, concated, and moved to the build folder.
</p>


<p>{% codeblock lang:ruby %}
$ gulp javascript</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpFile.js
Starting &lsquo;javascript&rsquo;&hellip;
Validate, Concat, Uglify, and Move all the javascript files
Finished &lsquo;javascript&rsquo; after 55 ms
{% endcodeblock %}</p>

<p>
  If you have an error here, be sure to check that your JavaScript is valid. Remember we were testing that last section.
</p>




<p>
  The build script should create our <code>/build/javascripts/main.js</code> file.
</p>


<p>{% codeblock /build/javascripts/main.js lang:ruby %}
function OMG(){var n=2;return n+10}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulp – Notify Pop Up]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/11/gulp-notify-pop-up/"/>
    <updated>2016-10-11T21:11:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/11/gulp-notify-pop-up</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/bunlong_gulp.jpg" width="600" alt="Gulp, Gulp – Notify Pop Up" />
</p>




<p>
  In the previous article, we used gulp to validate our JavaScript. The error message would appear in the console. While this is awesome, there is a chance we could miss it.
</p>




<p>
  Let’s use notifications to display a pop up window when we have a JavaScript error.
</p>




<p>
  There is a gulp plugin to send notifications.
</p>


<p>{% codeblock lang:ruby %}
$ npm install gulp-notify &mdash;save-dev
{% endcodeblock %}</p>

<p>
  For more information on <code>gulp-notify</code> check out <a href="https://www.npmjs.org/package/gulp-notify" target="_blank">https://www.npmjs.org/package/gulp-notify</a>
</p>




<p>
  Remember that gulp uses node’s streaming. It shouldn’t be a surprise that when <code>gulp-jsvalidate</code> finds an error, it emits an error event.
</p>




<p>
  All we need to do is handle the event and use <code>gulp-notify</code> to send a notification with the error message.
</p>


<p>{% codeblock gulpfile.js lang:ruby %}
&hellip;
var notify = require(&lsquo;gulp-notify&rsquo;);
&hellip;</p>

<p>&hellip;
gulp.task(&lsquo;javascript&rsquo;, function () {
  console.log(&ldquo;Validate JavaScript&rdquo;);
  return gulp.src(&ldquo;contents/javascripts/**.js&rdquo;)</p>

<pre><code>.pipe(jsValidate())
.on("error", notify.onError(function(error) {
  return error.message;
}));
</code></pre>

<p>});
&hellip;
{% endcodeblock %}</p>

<p>
  Since our JavaScript is now valid, we need to make it invalid so we can see the error message.
</p>


<p>{% codeblock /contests/javascript/somejs.js lang:ruby %}
function OMG() {
  var x * 2;
  return x + 10;
}
{% endcodeblock %}</p>

<p>
  Now when we run gulp javascript we will get a notification window that an error was found.
</p>


<p>{% codeblock lang:ruby %}
$ gulp javascript</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpFile.js
Starting &lsquo;javascript&rsquo;&hellip;
Validate JavaScript
gulp-notify: [Error running Gulp] Line 3: Unexpected token *
&lsquo;javascript&rsquo; errored after 41 ms Line 3: Unexpected token *
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulp – Validate JavaScript]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/11/gulp-validate-javascript/"/>
    <updated>2016-10-11T11:42:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/11/gulp-validate-javascript</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/bunlong_gulp.jpg" width="600" alt="Gulp, Gulp – Validate JavaScript" />
</p>




<p>
  The web runs on more than HTML and CSS, It runs on JavaScript. Let’s perform some common JavaScript build operations with gulp.
</p>




<p>
  We will first look into validating our JavaScript using gulp.
</p>




<p>
  And yes... there is a plugin for that.
</p>


<p>{% codeblock lang:ruby %}
$ npm install gulp-jsvalidate &mdash;save-dev
{% endcodeblock %}</p>

<p>
  For more information on <code>gulp-jsvalidate</code> check out <a href="https://github.com/sindresorhus/gulp-jsvalidate" target="_blank">https://github.com/sindresorhus/gulp-jsvalidate</a>.
</p>




<p>
  We will now create a new Javascript task in our <code>gulpfile.js</code>. At first, all we will do is validate our Javascript in a new <code>/contents/javascripts</code> folder.
</p>


<p>{% codeblock /gulpfile.js lang:ruby %}
&hellip;
var jsValidate = require(&lsquo;gulp-jsvalidate&rsquo;);
&hellip;</p>

<p>&hellip;
gulp.task(&lsquo;javascript&rsquo;, function () {
  console.log(&ldquo;Validate JavaScript&rdquo;);
  return gulp.src(&ldquo;contents/javascripts/**.js&rdquo;)</p>

<pre><code>.pipe(jsValidate());
</code></pre>

<p>});
&hellip;
{% endcodeblock %}</p>

<p>
  Time to test out our new task and plugin. Create a javascript file and make a syntax error.
</p>


<p>{% codeblock /contents/javascript/somejs.js lang:ruby %}
function OMG() {
  var x * 2; // this is not valid!
  return x + 10;
}
{% endcodeblock %}</p>

<p>
  Now when we run our javascript task, we will get an error message in the terminator:
</p>


<p>{% codeblock lang:ruby %}
$ gulp javascript</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpfile.js
Starting &lsquo;javascript&rsquo;&hellip;
&lsquo;javascript&rsquo; errored after 14 ms Line 3: Unexpected token *
{% endcodeblock %}</p>

<p>
  When we fix the error and then run our gulp task, we won’t get that error message:
</p>


<p>{% codeblock /contents/javascript/somejs.js lang:ruby %}
function OMG() {
  var x = 2;
  return x + 10;
}
{% endcodeblock %}</p>

<p>{% codeblock lang:ruby %}
$ gulp javascript</p>

<p>Using gulpfile ~/YOUR_DIRECTORY/gulpfile.js
Starting &lsquo;javascript&rsquo;&hellip;
Validate JavaScript
Finished &lsquo;javascript&rsquo; after 14 ms
{% endcodeblock %}</p>

<p>
  Sweet codes! Gulp can now check if our JavaScript is valid. But the error message in the console is rather bland, lets find a better way to tell us that we messed up.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulp – Handling Errors with Streams]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/10/gulp-handling-errors-with-streams/"/>
    <updated>2016-10-10T22:08:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/10/gulp-handling-errors-with-streams</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/gulpjs.jpg" width="600" alt="Gulp, Gulp – Handling Errors with Streams" />
</p>




<p>
  What if the file was named incorrectly? What happens?
</p>




<p>
  Change the string <code>index.html</code> to <code>OMG_WRONG_FILE.html</code> and rerun the script.
</p>


<p>{% codeblock /streams.js lang:ruby %}
var fs = require(&ldquo;fs&rdquo;);
var stream = fs.createReadStream(__dirname + &ldquo;/contents/OMG_WRONG_FILE.html&rdquo;);</p>

<p>stream.on(&ldquo;data&rdquo;, function(chunk) {
  // just output chunk to terminal
  console.log(chunk.toString());
});</p>

<p>stream.on(&ldquo;end&rdquo;, function() {
  console.log(&ldquo;END&rdquo;);
});
{% endcodeblock %}</p>

<p>
  Running the script this time results in:
</p>


<p>{% codeblock lang:ruby %}
$ node streams.js</p>

<p>events.js:72</p>

<pre><code>    throw er; // Unhandled 'error' event
</code></pre>

<p>Error: ENOENT, open &lsquo;~/YOUR_DIRECTORY/OMG_WRONG_FILE.html&rsquo;
{% endcodeblock %}</p>

<p>
  If we read the error message carefully, then we can see that there is an error event we can listen to. So lets listen for that event.
</p>


<p>{% codeblock /streams.js lang:ruby %}
&hellip;
stream.on(&ldquo;error&rdquo;, function(er) {
  console.log(&ldquo;error&rdquo;, er);
});
{% endcodeblock %}</p>

<p>
  Now we rerun the script and see:
</p>


<p>{% codeblock lang:ruby %}
$ node streams.js</p>

<p>error { [Error: ENOENT, open &lsquo;/Users/bunlong/js/gulp/contents/OMG_WRONG_FILE.html&rsquo;]
  errno: -2,
  code: &lsquo;ENOENT&rsquo;,
  path: &lsquo;~/YOUR_DIRECTORY/contents/OMG_WRONG_FILE.html&rsquo; }
{% endcodeblock %}</p>

<p>
  And that is it for now. We will come back and use some of what we learned later.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gulp – Streams]]></title>
    <link href="http://geekhmer.github.io/blog/2016/10/04/gulp-streams/"/>
    <updated>2016-10-04T09:18:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/10/04/gulp-streams</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/gulpjs.jpg" width="600" alt="Gulp, Gulp – Minify Our CSS" />
</p>




<p>
  Before we continue, I think a brief detour to cover some basics of Node streams would be helpful.
</p>




<p>
  Lets create a simple Node script to read a <code>index.html</code> file we will create:
</p>


<p>{% codeblock /contents/index.html lang:ruby %}
&lt;!DOCTYPE html>
<html>
<head>
  <title>Learning Gulp</title>
</head>
<body>
  <h1>Hello Gulp!</h1>
</body>
</html>
{% endcodeblock %}</p>

<p>
  First we require the file system library <code>fs</code> and create a read stream.
</p>


<p>{% codeblock /streams.js lang:ruby %}
var fs = require(&ldquo;fs&rdquo;);
var stream = fs.createReadStream(__dirname + &ldquo;/contents/index.html&rdquo;);
{% endcodeblock %}</p>

<p>
  <code>_dirname</code> is a helper that returns the absolute path of the code file being run.
</p>




<p>
  Node reads files asynchronously. This is normally where we could dive into what "non-blocking I/O" means vs threads, etc. This is a guide about gulp though so I will keep this detour basic.
</p>




<p>
  For our purposes, this means that we have to listen to <strong>events</strong> from the stream to be able to read the file.
</p>




<p>
  The events we are going to listen to are <code>data</code> and <code>end</code>.
</p>




<p>
  <code>data</code> fires when a chunk of the file has been read and returned. <strong>This chunk is not always the entire file</strong>. In fact, you should assume it is not the entire file.
</p>


<p>{% codeblock /streams.js lang:ruby %}
&hellip;
stream.on(&ldquo;data&rdquo;, function(chunk) {
  // just output chunk to terminal
  console.log(chunk.toString());
});
{% endcodeblock %}</p>

<p>
  <code>end</code> fires when the file has been completly read.
</p>


<p>{% codeblock /streams.js lang:ruby %}
&hellip;
stream.on(&ldquo;data&rdquo;, function(chunk) {
  // just output chunk to terminal
  console.log(chunk.toString());
});
{% endcodeblock %}</p>

<p>
  Now altogether, <code>streams.js</code> looks like:
</p>


<p>{% codeblock /streams.js lang:ruby %}
var fs = require(&ldquo;fs&rdquo;);
var stream = fs.createReadStream(__dirname + &ldquo;/contents/index.html&rdquo;);</p>

<p>stream.on(&ldquo;data&rdquo;, function(chunk) {
  console.log(chunk.toString());
});</p>

<p>stream.on(&ldquo;end&rdquo;, function() {
  console.log(&ldquo;END&rdquo;);
});
{% endcodeblock %}</p>

<p>
  Now if you run the node script in the terminal, you should see:
</p>


<p>{% codeblock lang:ruby %}
$ node streams.js</p>

<p>&lt;!DOCTYPE html>
<html>
<head>
  <title>Learning Gulp</title>
</head>
<body>
  <h1>Hello Gulp!</h1>
</body>
</html>
END
{% endcodeblock %}</p>

<p>
  So far so good, That’s it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
