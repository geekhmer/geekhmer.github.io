<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby Metaprogramming | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby-metaprogramming/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2015-07-11T22:45:00+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AbstractClass]]></title>
    <link href="http://geekhmer.github.io/blog/2013/12/07/abstractclass/"/>
    <updated>2013-12-07T22:31:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2013/12/07/abstractclass</id>
    <content type="html"><![CDATA[<p>{% codeblock example lang:ruby %}
class AbstractKlass<br/>
  def method_name</p>

<pre><code>puts "#{hello} #{name}"  
</code></pre>

<p>  end<br/>
end</p>

<p>class ConcreteKlass &lt; AbstractKlass<br/>
  def hello; &ldquo;Hello&rdquo;; end
  def name; &ldquo;Rubyist&rdquo;; end</p>

<p>  # def hello
  #   &ldquo;Hello&rdquo;
  # end</p>

<p>  # def name
  #   &ldquo;Rubyist&rdquo;
  # end
end</p>

<p>ConcreteKlass.new.method_name # => &ldquo;Hello Rubyist"<br/>
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[method_missing]]></title>
    <link href="http://geekhmer.github.io/blog/2013/11/30/method-missing/"/>
    <updated>2013-11-30T11:15:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2013/11/30/method-missing</id>
    <content type="html"><![CDATA[<p>
  method_missing use for creating dynamic methods.
</p>




<p>
  <strong>example</strong>
</p>


<p>{% codeblock example lang:ruby %}
class Klass
  def method_missing(method_name, *args, &amp;block)</p>

<pre><code>if method_name.to_s =~ /^find_by_(.+)$/
  run_find_by_method($1, *args, &amp;block)
else
  super
end
</code></pre>

<p>  end</p>

<p>  def run_find_by_method(attrs, *args, &amp;block)</p>

<pre><code>attrs = attrs.split('_and_')

attrs_with_args = [attrs, args].transpose

conditions = Hash[attrs_with_args]

str = ''
conditions.each { |key, value|
  str += "#{key} = '#{value}' and "
}

p "select * from tbl where #{str[0..-6]}"
</code></pre>

<p>  end
end</p>

<p>k = Klass.new
k.find_by_name(&ldquo;Bunlong&rdquo;)
k.find_by_name_and_email(&ldquo;Bunlong&rdquo;, &ldquo;<a href="&#109;&#x61;&#x69;&#108;&#116;&#x6f;&#58;&#x62;&#x75;&#110;&#108;&#111;&#110;&#103;&#46;&#x76;&#97;&#110;&#x40;&#103;&#109;&#x61;&#x69;&#108;&#x2e;&#x63;&#111;&#109;">&#98;&#x75;&#110;&#108;&#111;&#110;&#103;&#x2e;&#x76;&#97;&#110;&#x40;&#x67;&#x6d;&#x61;&#x69;&#x6c;&#46;&#99;&#x6f;&#109;</a>&rdquo;)
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[include_vs_extend]]></title>
    <link href="http://geekhmer.github.io/blog/2013/11/30/include-vs-extend/"/>
    <updated>2013-11-30T10:56:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2013/11/30/include-vs-extend</id>
    <content type="html"><![CDATA[<p>
  <strong>include</strong><br/>
  include use for adding methods to an instance of a class.
</p>




<p>
  <strong>example</strong>
</p>


<p>{% codeblock example lang:ruby %}
module Foo
  def foo</p>

<pre><code>p 'Hi foo'
</code></pre>

<p>  end
end</p>

<p>class Bar
  include Foo
end</p>

<p>bar = Bar.new
bar.foo # => Hi foo</p>

<p>Bar.foo # => NoMethodError: undefined method ‘foo’ for Bar:Class
{% endcodeblock %}</p>

<p>
  <strong>extend</strong><br/>
  extend use for adding class methods.
</p>




<p>
  <strong>example</strong>
</p>


<p>{% codeblock example lang:ruby %}
module Foo
  def foo</p>

<pre><code>p 'Hi foo'
</code></pre>

<p>  end
end</p>

<p>class Baz
  extend Foo
end</p>

<p>Bar.foo # => Hi foo</p>

<p>bar = Bar.new
bar.foo # => NoMethodError: undefined method ‘foo’ for #&lt;Baz:0x1e708>
{% endcodeblock %}</p>

<p>
  <strong>Using include to append both class and instance methods</strong><br/>
  You will see in Ruby is to use include to append both class and instance methods.<br/>
  The reason for this is that include has a self.included hook you can use to modify 
  the class that is including a module.
</p>




<p>
  <strong>example</strong>
</p>


<p>{% codeblock example lang:ruby %}
module Foo
  def self.included(base)</p>

<pre><code>base.extend(ClassMethods)
</code></pre>

<p>  end</p>

<p>  module ClassMethods</p>

<pre><code>def bar
  p 'class method'
end
</code></pre>

<p>  end</p>

<p>  def foo</p>

<pre><code>p 'instance method'
</code></pre>

<p>  end
end</p>

<p>class Bar
  include Foo
end</p>

<p>Bar.bar # => class method
Bar.foo # => NoMethodError: undefined method ‘foo’ for Baz:Class</p>

<p>Bar.new.foo # => instance method
Bar.new.bar # => NoMethodError: undefined method ‘bar’ for #&lt;Baz:0x1e3d4>
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[define_singleton_method]]></title>
    <link href="http://geekhmer.github.io/blog/2013/11/30/define-singleton-method/"/>
    <updated>2013-11-30T09:16:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2013/11/30/define-singleton-method</id>
    <content type="html"><![CDATA[<p>
  define_singleton_method use to define singleton method.
</p>




<p>
  <strong>example</strong>
</p>


<p>{% codeblock example lang:ruby %}
class Sayer
  def self.shouts(*words)</p>

<pre><code>words.each do |word|
  define_singleton_method "shout_#{word}" do
    p word
  end
end
</code></pre>

<p>  end</p>

<p>  shouts :hello, :goodbye
end</p>

<p>Sayer.shout_hello
Sayer.shout_goodbye
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
