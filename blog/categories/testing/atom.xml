<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: testing | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/testing/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2015-11-23T13:34:15+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Test Models With RSpec in Ruby on Rails]]></title>
    <link href="http://geekhmer.github.io/blog/2014/08/07/test-models-with-rspec-in-ruby-on-rails/"/>
    <updated>2014-08-07T09:40:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/08/07/test-models-with-rspec-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" />
</p>




<p>
  Testing is a good pratice. You should be doing it. It will make you a better programmer and save you a great deal of headache as your web app grows up. It is especially important when working alongside other programmers. Testing is not perfect though so don't try to be perfect. Just get started, and you will improve as time goes on.
</p>




<p>
  <strong>How should I be testing?</strong><br/>
  - Using RSpec & factorygirl.<br/>
  - Testing the Model.
</p>




<p>
  <strong>Installation</strong><br/>
  Add rspec-rails and factorygirl to both the :development and :test groups in the Gemfile:
</p>


<p>{% codeblock Gemfile lang:ruby %}
group :development, :test do
  gem &lsquo;factory_girl_rails&rsquo;, &lsquo;4.2.1&rsquo;
  gem &lsquo;rspec-rails&rsquo;, &lsquo;~> 3.0.0&rsquo;
end
{% endcodeblock %}</p>

<p>
  Download and install by running command:<br>
</p>


<p>{% codeblock lang:ruby %}
bundle install
{% endcodeblock %}</p>

<p>
  Initialize the spec/ directory (where specs will reside) with:
</p>


<p>{% codeblock lang:ruby %}
rails generate rspec:install
{% endcodeblock %}</p>

<p>
  This adds the following files which are used for configuration:<br/>
  - .rspec<br/>
  - spec/spec_helper.rb<br/>
  - spec/rails_helper.rb
</p>




<p>
  <strong>Generators</strong><br/>
  Once installed, RSpec and factorygirl will generate spec files instead of Test::Unit test files when run commands like: <code>rails generate model</code> and <code>rails generate controller</code> are used.
</p>




<p>
  Example:
</p>


<p>{% codeblock lang:ruby %}
rails generate model Post
{% endcodeblock %}</p>

<p>
  After you run the command above this adds the following directory and file:<br/>
  - spec/models/posts.rb<br/>
  - spec/factories/posts.rb
</p>




<p>
  <strong>Let's get started the Model testing</strong>
</p>




<p>
  Assume we have three Models such as post.rb, category.rb, categorization.rb:
</p>


<p>{% codeblock post.rb lang:ruby %}
class Post &lt; ActiveRecord::Base
  validates :title, length: { minimum: 10, maximum: 100 }, presence: true, uniqueness: true
  validates :body, length: { minimum: 20, maximum: 200 }
  validates :status, length: { minimum: 2, maximum: 20 }, presence: true
  validates :category_id, presence: true</p>

<p>  has_many :categorizations
  has_many :categories, through: :categorizations</p>

<p>  scope :search_by_title, &ndash;> (title) { where(&ldquo;(title like ?) OR title in (?)&rdquo;, &ldquo;%#{title}%&rdquo;, title.split) }
end
{% endcodeblock %}</p>

<p>{% codeblock category.rb lang:ruby %}
class Category &lt; ActiveRecord::Base
  validates :name, length: { minimum: 10, maximum: 50 }, presence: true, uniqueness: true
  validates :short_name, length: { minimum: 10, maximum: 50 }, presence: true, uniqueness: true
  validates :description, length: { maximum: 200 }</p>

<p>  has_many :categorizations
  has_many :posts, through: :categorizations
end
{% endcodeblock %}</p>

<p>{% codeblock categorization.rb lang:ruby %}
class Categorization &lt; ActiveRecord::Base
  validates :category_id, presence: true
  validates :post_id, presence: true</p>

<p>  belongs_to :category
  belongs_to :post
end
{% endcodeblock %}</p>

<p>
  Next, we define default factorygirl object for each Models in spec/factories/:
</p>


<p>{% codeblock posts.rb lang:ruby %}
FactoryGirl.define do
  factory :post do</p>

<pre><code>title 'Ruby on Rails'
body 'Ruby on Rails is good'
status 'open'
category_id 1
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock categories.rb lang:ruby %}
FactoryGirl.define do
  factory :category do</p>

<pre><code>id 1
name 'programming'
short_name 'programming'
description 'computer programming'
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock categorizations.rb lang:ruby %}
FactoryGirl.define do
  factory :categorization do</p>

<pre><code>category_id '1'
post_id '1'
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Here, how we test each Models in spec/models/:
</p>


<p>{% codeblock post.rb lang:ruby %}
require &lsquo;spec_helper&rsquo;</p>

<p>describe Post, &lsquo;validation&rsquo; do
  it { should ensure_length_of(:title).is_at_least(10) }
  it { should ensure_length_of(:title).is_at_most(100) }
  it { should validate_presence_of(:title) }
  it { should validate_uniqueness_of(:title) }</p>

<p>  it { should ensure_length_of(:body).is_at_least(20) }
  it { should ensure_length_of(:body).is_at_most(200) }</p>

<p>  it { should ensure_length_of(:status).is_at_least(2) }
  it { should ensure_length_of(:status).is_at_most(20) }
  it { should validate_presence_of(:status) }</p>

<p>  it { should validate_presence_of(:category_id) }
end</p>

<p>describe Post, &lsquo;association&rsquo; do
  it { should have_many(:categorizations) }
  it { should have_many(:categories).through(:categorizations) }
end</p>

<p>describe Post, &lsquo;column_specification&rsquo; do
  it { should have_db_column(:title).of_type(:string).with_options(length: { minimum: 10, maximum: 100 }, presence: true, uniqueness: true) }
  it { should have_db_column(:body).of_type(:text).with_options(length: { minimum: 20, maximum: 200 }) }
  it { should have_db_column(:status).of_type(:string).with_options(length: { minimum: 2, maximum: 20, presence: true }) }
  it { should have_db_column(:category_id).of_type(:integer) }</p>

<p>  it { should have_db_index(:title).unique(true) }
end</p>

<p>describe Post, &lsquo;.search_by_name&rsquo; do
  before(:each) do</p>

<pre><code>FactoryGirl.create(:post, title: 'Ruby on Rails')
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns post that match with title&rsquo; do</p>

<pre><code>Post.search_by_title('Ruby on Rails').count.should eql 1
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns post that like title&rsquo; do</p>

<pre><code>Post.search_by_title('ruby on rails').count.should eql 1
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns post when title is blank&rsquo; do</p>

<pre><code>Post.search_by_title('').count.should eql 1
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns empty when title is not match&rsquo; do</p>

<pre><code>Post.search_by_title('not match').count.should eql 0
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock category.rb lang:ruby %}
require &lsquo;spec_helper&rsquo;</p>

<p>describe Category, &lsquo;validation&rsquo; do
  it { should ensure_length_of(:name).is_at_least(10) }
  it { should ensure_length_of(:name).is_at_most(50) }
  it { should validate_presence_of(:name) }
  it { should validate_uniqueness_of(:name) }</p>

<p>  it { should ensure_length_of(:short_name).is_at_least(10) }
  it { should ensure_length_of(:short_name).is_at_most(50) }
  it { should validate_presence_of(:short_name) }
  it { should validate_uniqueness_of(:short_name) }
end</p>

<p>describe Category, &lsquo;association&rsquo; do
  it { should have_many(:categorizations) }
  it { should have_many(:posts).through(:categorizations) }
end</p>

<p>describe Category, &lsquo;column_specification&rsquo; do
  it { should have_db_column(:name).of_type(:string).with_options(length: { minimum: 10, maximum: 50 }, presence: true, uniqueness: true) }
  it { should have_db_column(:short_name).of_type(:string).with_options(length: { minimum: 10, maximum: 50 }, presence: true, uniqueness: true) }
  it { should have_db_column(:description).of_type(:text).with_options(length: { maximum: 200 }) }
end
{% endcodeblock %}</p>

<p>{% codeblock categorization.rb lang:ruby %}
require &lsquo;spec_helper&rsquo;</p>

<p>describe Categorization, &lsquo;validation&rsquo; do
  it { should validate_presence_of(:category_id) }
  it { should validate_presence_of(:post_id) }
end</p>

<p>describe Categorization, &lsquo;association&rsquo; do
  it { should belong_to(:category) }
  it { should belong_to(:post) }
end</p>

<p>describe Categorization, &lsquo;column_specification&rsquo; do
  it { should have_db_column(:category_id).of_type(:integer).with_options(presence: true) }
  it { should have_db_column(:post_id).of_type(:integer).with_options(presence: true) }
end
{% endcodeblock %}</p>

<p>
  To run Models specs use the following command:
</p>


<p>{% codeblock lang:ruby %}
rspec spec/models
{% endcodeblock %}</p>

<p>
  You should get back the response something like:
</p>




<p>
  <img src="http://geekhmer.github.io/images/model_testing.png" width="600"/>
</p>




<p>
  For more detail about <a href="https://github.com/rspec/rspec-rails" target="_blank">RSpec</a>, <a href="https://github.com/thoughtbot/factory_girl" target="_blank">FactoryGirl</a>.<br/>
  So far so good, We've already created 40 models specs to test model. :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What We Should Test with RSpec in Rails]]></title>
    <link href="http://geekhmer.github.io/blog/2014/08/04/what-we-should-test-with-rspec-in-rails/"/>
    <updated>2014-08-04T22:27:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/08/04/what-we-should-test-with-rspec-in-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" />
</p>




<p>
  Well, what is takes to begin testing Rails applications. The hardest part of being a beginner is that you often don't know what you should test with RSpec in Rails.
</p>




<p>
  Here is the most important thing is that you are testing: Feature specs, Model specs, Controller specs, View specs, Route specs.
</p>




<p>
  <strong>Feature specs</strong><br/>
  Feature specs is a kind of acceptance test, the tests that walk through your entire application ensuring that each of the components work together.<br/>
  They are written from the perspective of a user clicking around the application and filling in forms on the page.<br/>
  While Feature specs are great for testing high level functionality, keep in mind that feature specs is slow to run.
</p>




<p>
  <strong>Model specs</strong><br/>
  Model specs are similar to unit tests in that they are used to test smaller parts of the system, such as classes or methods, and they interact with the database too.
</p>




<p>
  <strong>Controller specs</strong><br/>
  When testing multiple paths through a controller is necessary, we favor using controller specs over feature specs, as they are faster to run and often easier to write.
</p>




<p>
  <strong>View specs</strong><br/>
  View specs is great for testing the conditional display of information in the templates. Most developers forget about these tests and use feature specs instead.<br/>
  While you can cover each view conditional with a feature specs, I prefer to user view specs.
</p>




<p>
  <strong>Route specs</strong><br/>
  Most Ruby on Rails developers don’t test their routes, If you ever need to test an abstract base controller independently from any subclass, you will like need to add route specs for your testing.
</p>




<p>
  So far so good, this was just an overview of what we should get started testing Rails. :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Routes with RSpec in Ruby on Rails]]></title>
    <link href="http://geekhmer.github.io/blog/2014/07/30/test-routes-with-rspec-in-ruby-on-rails/"/>
    <updated>2014-07-30T22:47:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/07/30/test-routes-with-rspec-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>
  Most Ruby on Rails developers don’t test their routes, they focus on Model testing, Controller testing, Features or View testing, Helper testing, and try to catch every possible scenarios.<br/>I would like to show how to test route separately. 
</p>




<p>
  Sample routes.rb:
</p>


<p>{% codeblock routes.rb lang:ruby %}
resources :products
{% endcodeblock %}</p>

<p>
  Here is routes lists thats have been created:
</p>


<p>{% codeblock lang:ruby %}</p>

<pre><code> root        /                            products#index
posts GET    /products(.:format)          products#index
      POST   /products(.:format)          products#create
</code></pre>

<p> new_post GET    /products/new(.:format)      products#new
edit_post GET    /products/:id/edit(.:format) products#edit</p>

<pre><code> post GET    /products/:id(.:format)      products#show
      PUT    /products/:id(.:format)      products#update
      DELETE /products/:id(.:format)      products#destroy
</code></pre>

<p>{% endcodeblock %}</p>

<p>
  Testing for each routes in routing/products_routing_spec.rb:
</p>


<p>{% codeblock products_routing_spec.rb lang:ruby %}
require &lsquo;spec_helper&rsquo;</p>

<p>describe &ldquo;routing to products&rdquo; do
  it &ldquo;routes /products to products#index&rdquo; do</p>

<pre><code>expect(get: "/products").to route_to(
  controller: "products",
  action: "index"
)
</code></pre>

<p>  end</p>

<p>  it &ldquo;routes /products/1 to products#show&rdquo; do</p>

<pre><code>expect(get: "/products/1").to route_to(
  controller: "products",
  action: "show",
  id: "1"
)
</code></pre>

<p>  end</p>

<p>  it &ldquo;routes /products/new to products#new&rdquo; do</p>

<pre><code>expect(get: "/products/new").to route_to(
  controller: "products",
  action: "new"
)
</code></pre>

<p>  end</p>

<p>  it &ldquo;routes /products to products#create&rdquo; do</p>

<pre><code>expect(post: "/products").to route_to(
  controller: "products",
  action: "create"
)
</code></pre>

<p>  end</p>

<p>  it &ldquo;routes /products/1/edit to products#edit&rdquo; do</p>

<pre><code>expect(get: "/products/1/edit").to route_to(
  controller: "products",
  action: "edit",
  id: "1"
)
</code></pre>

<p>  end</p>

<p>  it &ldquo;routes /products/1 to products#update&rdquo; do</p>

<pre><code>expect(put: "/products/1").to route_to(
  controller: "products",
  action: "update",
  id: "1"
)
</code></pre>

<p>  end</p>

<p>  it &ldquo;routes /products/1 to products#destroy&rdquo; do</p>

<pre><code>expect(delete: "/products/1").to route_to(
  controller: "products",
  action: "destroy",
  id: "1"
)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Testing unroutable:
</p>


<p>{% codeblock routes.rb lang:ruby %}
resources :products, except: [:show]
{% endcodeblock %}</p>

<p>{% codeblock products_routing_spec.rb lang:ruby %}
it &ldquo;does not routes /products/1 to products#show&rdquo; do
  expect(:get => &ldquo;posts/1&rdquo;).not_to be_routable
end
{% endcodeblock %}</p>

<p>
  So far so good, Let enjoy the routes testing in your Ruby on Rails application. :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Acceptance/Feature test, Integration test, Unit test, Smoke test, Regression test]]></title>
    <link href="http://geekhmer.github.io/blog/2013/10/14/acceptance-slash-feature-test-integration-test-unit-test-smoke-test-regression-test/"/>
    <updated>2013-10-14T21:12:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2013/10/14/acceptance-slash-feature-test-integration-test-unit-test-smoke-test-regression-test</id>
    <content type="html"><![CDATA[<p>
  <strong>1. What is Acceptance/Feature test?</strong><br/>
  Is the testing use to test the customer's specific scenarios when a user story has been correctly implemented. A story can have one or many acceptance tests, whatever it takes to ensure the functionality works.
</p>




<p>
  <strong>2. What is Integration test?</strong><br/>
  Is the testing use to expose defects in the interfaces and interaction between integrated components (modules).
</p>




<p>
  <strong>3. What is Unit test?</strong><br/>
   Also known as component testing, refers to tests that verify the functionality of a specific section of code, usually at the function level. In an object-oriented environment, this is usually at the class level.
   These types of tests is used to ensure that the specific function is working as expected. One function might have multiple tests.
</p>




<p>
  <strong>4. What is Smoke test?</strong><br/>
  Is the quick testing to make sure everything looks okay before you get involved in the more testing.
</p>




<p>
  <strong>5. What is Regression test?</strong><br/>
  Is the testing to make sure you haven't broken anything. Everything that used to work should still work.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test and Behaviour Driven Development (TDD/BDD)]]></title>
    <link href="http://geekhmer.github.io/blog/2013/10/12/test-and-behaviour-driven-development-tdd-slash-bdd/"/>
    <updated>2013-10-12T00:36:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2013/10/12/test-and-behaviour-driven-development-tdd-slash-bdd</id>
    <content type="html"><![CDATA[<p>
  <strong>1. What is TDD/BDD?</strong><br/>
  Express expected behaviour before writing code.
</p>




<p>
  <strong>2. Why is TDD/BDD a good thing?</strong><br/>
  - Enjoy more efficient and predictable course of development.<br/>
  - Find and fix bugs faster.<br/>
  - Prevent bugs from reappearing.<br/>
  - Improve the design of our software.<br/>
  - Reliable document.
</p>




<p>
  <strong>3. How do we do TDD/BDD?</strong><br/>
  - Write test programs.<br/>
  - Run the tests automatically.
</p>




<p>
  <strong>Workflow/Processing</strong>
</p>




<p> 
  TDD<br/>
  <a class="fancybox" href="http://geekhmer.github.io/images/tdd.png"><img src="http://geekhmer.github.io/images/tdd.png" /></a>
</p>




<p>
  BDD<br/>
  <a class="fancybox" href="http://geekhmer.github.io/images/tdd.png"><img src="http://geekhmer.github.io/images/bdd.png" /></a>
</p>

]]></content>
  </entry>
  
</feed>
