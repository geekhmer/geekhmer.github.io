<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Javascript | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2015-11-23T13:34:15+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What is Flux?]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/22/what-is-flux/"/>
    <updated>2015-11-22T16:27:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/22/what-is-flux</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/react_flux.jpg" width="600" alt="What is Flux?" />
</p>




<p>
  Flux is an architecture that Facebook uses internally when working with React. It is not a framework or a library. It is a new kind of architecture that complements React and the concept of Unidirectional Data Flow (Central to the Flux Pattern).
</p>




<p>
  Facebook provide a Dispatcher javascript library. The dispatcher is a kind of global pub/sub handler that broadcasts payloads to registered callbacks.
</p>




<p>
  Flux architecture will use this Dispatcher javascript library, along with NodeJS’s EventEmitter module in order to set up an event system that helps manage an applications state.
</p>




<p>
  <strong>Flux have 4 layers:</strong><br/>
  - <code>Actions</code> - Helper methods that facilitate passing data to the Dispatcher.<br/>
  - <code>Dispatcher</code> - Receives actions and broadcasts payloads to registered callbacks.<br/>
  - <code>Stores</code> - Containers for application state & logic that have callbacks registered to the dispatcher.<br/>
  - <code>Controller Views</code> - React Components that grab the state from Stores and pass it down via props to child components.
</p>




<p>
  <strong>Structure and Data Flow </strong><br/>
  Data in a Flux application flows in a single direction:<br/>
</p>




<p>
  <img src="http://geekhmer.github.io/images/flux_diagram_1.png" width="600" alt="What is Flux?" />
</p>




<p>
  The dispatcher, stores and views are independent nodes with distinct inputs and outputs. The actions are simple objects containing the new data and an identifying type property.
</p>




<p>
  The views may cause a new action to be propagated through the system in response to user interactions:
</p>




<p>
  <img src="http://geekhmer.github.io/images/flux_diagram_2.png" width="600" alt="What is Flux?" />
</p>




<p>
  All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own <code>setState()</code> method, causing a re-rendering of themselves and all of their descendants in the component tree.
</p>




<p>
  <img src="http://geekhmer.github.io/images/flux_diagram_3.png" width="600" alt="What is Flux?" />
</p>




<p>
  <strong>Summary</strong><br/>
  Flux is a pattern for unidirectional data flows Actions encapsulate events Dispatcher is a central hub that holds callbacks Stores hold app state Many implementations
</p>




<p>
  So far after reading this article, I hope that if you didn’t get Facebook’s Flux Architecture before, that now you can say you do. 
</p>




<p>
  If you want to use the Flux architecture. but you don't know how to use it and which library you should use, please stay turned for the next article. See you!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactJS Composable Components]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/22/reactjs-composable-components/"/>
    <updated>2015-11-22T13:17:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/22/reactjs-composable-components</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/reactjs.png" width="600" alt="ReactJS Composable Components" />
</p>




<p>
  ReactJS is all about building reusable components. In fact, with React the only thing you do is build components. Since they're so encapsulated, components make code reuse, testing, and separation of concerns easy. Let see the example below:
</p>


<p>{% codeblock lang:javascript %}
&lt;!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title></title>
  <script type="text/javascript" src="http://fb.me/react-0.12.2.js"></script>
  <script type="text/javascript" src="http://fb.me/JSXTransformer-0.12.2.js"></script>
</head>
<body>
  <script type="text/jsx"></p>

<pre><code>var App = React.createClass({
  getInitialState: function() {
    return {
      red: 0
    }
  },
  update: function(e) {
    this.setState({
      red: this.refs.red.refs.inp.getDOMNode().value
    });
  },
  render: function() {
    return (
      &lt;div&gt;
        &lt;NumInput 
          ref="red"
          min={0}
          max={255}
          step={0.01}
          val={this.state.red}
          type="number"
          label="Red"
          update={this.update} /&gt;
      &lt;/div&gt;
    );
  }
});

var NumInput = React.createClass({
  propTypes: {
    min: React.PropTypes.number,
    max: React.PropTypes.number,
    step: React.PropTypes.number,
    val: React.PropTypes.number,
    label: React.PropTypes.string,
    update:React.PropTypes.func.isRequired,
    type: React.PropTypes.oneOf(['number', 'range'])
  },
  getDefaultProps: function() {
    return {
      min: 0,
      max: 0,
      step: 1,
      val: 0,
      label: '',
      type: 'range'
    }
  },
  render: function() {
    var label = this.props.label !== '' ? &lt;label&gt;{this.props.label} {this.props.val}&lt;/label&gt; : ''
    return (
        &lt;div&gt;
          &lt;input 
            ref="inp" 
            type={this.props.type} 
            min={this.props.min} 
            max={this.props.max} 
            step={this.props.step} 
            defaultValue={this.props.val} 
            onChange={this.props.update} /&gt;
            {label}
        &lt;/div&gt;
    );
  }
});

React.render(&lt;App txt="this is the txt prop" /&gt;, document.body);
</code></pre>

<p>  </script>
</body>
</html>
{% endcodeblock %}</p>

<p>
  So far go good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactJS Mixins]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/21/reactjs-mixins/"/>
    <updated>2015-11-21T18:10:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/21/reactjs-mixins</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/reactjs.png" width="600" alt="ReactJS Mixins" />
</p>




<p>
  Components are the best way to reuse code in React, but sometimes very different components may share some common functionality. These are sometimes called cross-cutting concerns. React provides mixins to solve this problem.
</p>




<p>
  Example:
</p>




<p>
  Let's create a simple mixin that uses lifecycle methods for using in two components.
</p>


<p>{% codeblock lang:javascript %}
&lt;!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title></title>
  <script type="text/javascript" src="http://fb.me/react-0.12.2.js"></script>
  <script type="text/javascript" src="http://fb.me/JSXTransformer-0.12.2.js"></script>
</head>
<body>
  <script type="text/jsx"></p>

<pre><code>var ReactMixin = {
  getInitialState: function() {
    return {count: 0}
  },
  componentWillMount: function() {
    console.log('will mount');
  },
  incrementCount: function() {
    this.setState({count: this.state.count+1});
  }
}

var App = React.createClass({
  render: function() {
    return(
      &lt;div&gt;
        &lt;Button txt="this is the button" /&gt;
        &lt;br/&gt;
        &lt;Label txt="this is the label" /&gt;
      &lt;/div&gt;
    );
  }
});

var Button = React.createClass({
  mixins: [ReactMixin],
  render: function() {
    return &lt;button onClick={this.incrementCount}&gt;{this.props.txt} - {this.state.count}&lt;/button&gt;
  }
});

var Label = React.createClass({
  mixins: [ReactMixin],
  componentWillMount: function() {
    setInterval(this.incrementCount, 1000);
  },
  render: function() {
    return &lt;label&gt;{this.props.txt} - {this.state.count}&lt;/label&gt;
  }
});

ReactDOM.render(&lt;App /&gt;, document.body);
</code></pre>

<p>  </script>
</body>
</html>
{% endcodeblock %}</p>

<p>
  So far go good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactJS Component Lifecycle Unmounting]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/21/reactjs-component-lifecycle-unmounting/"/>
    <updated>2015-11-21T11:53:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/21/reactjs-component-lifecycle-unmounting</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/reactjs.png" width="600" alt="ReactJS Component Lifecycle Unmounting" />
</p>




<p>
  ReactJS mounting have 1 methods:<br/>
  - <code>componentWillUnmount()</code>: is invoked immediately before a component is unmounted and destroyed. Cleanup should go here.
</p>




<p>
  Example:
</p>


<p>{% codeblock lang:javascript %}
&lt;!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title></title>
  <script type="text/javascript" src="http://fb.me/react-0.12.2.js"></script>
  <script type="text/javascript" src="http://fb.me/JSXTransformer-0.12.2.js"></script>
</head>
<body>
  <script type="text/jsx"></p>

<pre><code>var Button = React.createClass({
  getInitialState: function() {
    return {
      val: 0
    }
  },
  handleUpdate: function() {
    this.setState({val: this.state.val + 1}
    );
  },
  componentWillMount: function() {
    console.log('mounting');
  },
  render: function() {
    console.log('rendering');
    return (
      &lt;div&gt;
        &lt;button onClick={this.handleUpdate}&gt;{this.state.val}&lt;/button&gt;
      &lt;/div&gt;
    );
  },
  componentDidMount: function() {
    console.log('mounted');
  },
  componentWillUnmount: function() {
    console.log('bye!');
  }
});

var App = React.createClass({
  handleMount: function() {
    React.render(&lt;Button /&gt;, document.getElementById('app'));
  },
  handleUnmount: function() {
    React.unmountComponentAtNode(document.getElementById('app'));
  },
  render: function() {
    return(
      &lt;div&gt;
        &lt;button onClick={this.handleMount}&gt;Mount&lt;/button&gt;
        &lt;button onClick={this.handleUnmount}&gt;Unmount&lt;/button&gt;
        &lt;div id="app"&gt;&lt;/div&gt;
      &lt;/div&gt;
    );
  }
});

React.render(&lt;App /&gt;, document.body);
</code></pre>

<p>  </script>
</body>
</html>
{% endcodeblock %}</p>

<p>
  In Button component <code>getInitialState()</code> method initial <code>val: 0</code> by default.
</p>




<p>
  When you click on Mount button, <code>componentWillMount()</code> method is invoked immediately before mounting occurs, and <code>render()</code> method render button into body DOM, and then <code>componentDidMount()</code> method is invoked immediately after mounting occurs.
</p>




<p>
  When you click on Unmount button, <code>componentWillUnmount()</code> is invoked immediately before a component is unmounted and destroyed.
</p>




<p>
  So far go good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactJS Component Lifecycle Updating]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/21/reactjs-component-lifecycle-updating/"/>
    <updated>2015-11-21T11:36:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/21/reactjs-component-lifecycle-updating</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/reactjs.png" width="600" alt="ReactJS Component Lifecycle Updating" />
</p>




<p>
  ReactJS mounting have 4 methods:<br/>
  - <code>componentWillReceiveProps(object nextProps)</code>: is invoked when a mounted component receives new props. This method should be used to compare <code>this.props</code> and nextProps to perform state transitions using <code>this.setState()</code>.<br/>
  - <code>shouldComponentUpdate(object nextProps, object nextState): boolean</code>: is invoked when a component decides whether any changes warrant an update to the DOM. Implement this as an optimization to compare <code>this.props</code> with <code>nextProps</code> and <code>this.state</code> with <code>nextState</code> and return <code>false</code> if React should skip updating.<br/>
  - <code>componentWillUpdate(object nextProps, object nextState)</code>: is invoked immediately before updating occurs. You cannot call <code>this.setState()</code> here.<br/>
  - <code>componentDidUpdate(object prevProps, object prevState)</code>: is invoked immediately after updating occurs.
</p>




<p>
  Example:
</p>


<p>{% codeblock lang:javascript %}
&lt;!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title></title>
  <script type="text/javascript" src="http://fb.me/react-0.12.2.js"></script>
  <script type="text/javascript" src="http://fb.me/JSXTransformer-0.12.2.js"></script>
</head>
<body>
  <script type="text/jsx"></p>

<pre><code>var Button = React.createClass({
  getInitialState: function() {
    return {increasing: false}
  },
  handleUpdate: function() {
    this.setProps({val: this.props.val+1});
  },
  componentWillReceiveProps: function(nextProps) {
    this.setState({increasing: nextProps.val &gt; this.props.val});
  },
  shouldComponentUpdate: function(nextProps, nextState) {
    return nextProps.val % 5 === 0;
  },
  render: function() {
    console.log(this.state.increasing);
    return(
      &lt;div&gt;
        &lt;button onClick={this.handleUpdate}&gt;{this.props.val}&lt;/button&gt;
      &lt;/div&gt;
    );
  },
  componentDidUpdate: function(prevProps, prevState) {
    console.log('prevProps', prevProps);
  }
});

ReactDOM.render(&lt;Button val={0} /&gt;, document.body);
</code></pre>

<p>  </script>
</body>
</html>
{% endcodeblock %}</p>

<p>
  So far go good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
