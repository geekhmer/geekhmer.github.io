<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2015-04-16T09:31:35+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails _filter vs _action]]></title>
    <link href="http://geekhmer.github.io/blog/2015/04/16/ruby-on-rails-filter-vs-action/"/>
    <updated>2015-04-16T09:13:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/04/16/ruby-on-rails-filter-vs-action</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" alt="Ruby on Rails _filter vs _action" />
</p>




<p>
  If you are coming to Rails 4 from earlier versions of Rails, you may have noticed the new <code>_action</code> methods floating around.
</p>




<p>
  Seeing these for the first time may have left you scratching your head a bit and asking "Aren't these the same as the <code>_filter</code> functions in previous versions of Rails?" The answer is a resounding YES. For Rails 4.x, the rails team decided to rename the functions to better describe what they are doing. Don't worry, the old functions still work. However it is recommended that you use the new syntax going forward, as the <code>_filter</code> functions may be deprecated in the future.
</p>




<p>
  Below shows a list of the old and new functions:
</p>


<table>
<thead>
<tr>
<th>Old Function </th>
<th> New Function</th>
</tr>
</thead>
<tbody>
<tr>
<td>before_filter </td>
<td> Abefore_action</td>
</tr>
<tr>
<td>after_filter </td>
<td> after_action</td>
</tr>
<tr>
<td>around_filter </td>
<td> around_action</td>
</tr>
<tr>
<td>append_after_filter </td>
<td> append_after_action</td>
</tr>
<tr>
<td>append_around_filter </td>
<td> append_around_actionor DOM classes.</td>
</tr>
<tr>
<td>prepend_around_filter </td>
<td> prepend_around_action</td>
</tr>
<tr>
<td>append_before_filter </td>
<td> append_before_action</td>
</tr>
<tr>
<td>skip_before_filter </td>
<td> skip_before_action</td>
</tr>
<tr>
<td>skip_around_filter </td>
<td> skip_around_action</td>
</tr>
<tr>
<td>skip_after_filter </td>
<td> skip_after_action</td>
</tr>
<tr>
<td>skip_filter </td>
<td> skip_action_callback</td>
</tr>
</tbody>
</table>


<br/>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Respond with JSON in Ruby on Rails Application]]></title>
    <link href="http://geekhmer.github.io/blog/2015/04/15/respond-with-json-in-ruby-on-rails-application/"/>
    <updated>2015-04-15T15:06:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/04/15/respond-with-json-in-ruby-on-rails-application</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" alt="Translate Your Ruby on Rails Application" />
</p>




<p>
  When building a RESTful API in Rails application, there are many different options and gems you can use to format your JSON responses. This isn't a post about how to build an API, but rather about some of the different popular options on how to define and structure JSON.
</p>




<p>
  <strong>RABL</strong><br/>
  <a href="http://www.leighhalliday.com/responding-with-json-in-rails" target="_blank">RABL</a> is a DSL for generating both JSON and XML. In my mind it has a similar feel to Jbuilder, which I'll discuss below. It's works by creating a view with the extension .rabl, and defining which attributes, nodes, and relations you wish to include in the JSON response.
</p>




<p>
  Here's an example:
</p>


<p>{% codeblock app/views/posts/index.rabl lang:ruby %}
collection @posts
attributes :id, :title, :subject
child(:user) { attributes :full_name }
node(:read) { |post| post.read_by?(@user) }
{% endcodeblock %}</p>

<p>
  <strong>Active Model Serializer</strong><br/>
  <a href="https://github.com/rails-api/active_model_serializers" target="_blank">Active Model Serializer</a> is a great way to build JSON responses using an object oriented approach. The objects have a very similar feel to how your ActiveModel object is set up in terms of attributes and relationships. It also allows you to choose your adapter-to decide what type of JSON structure is produced-or to build your own. Popular supported formats are JSON-API and JSON-HAL.
</p>


<p>{% codeblock lang:ruby %}
class PostSerializer &lt; ActiveModel::Serializer
  attributes :title, :body
  has_many :comments
  url :post
end
{% endcodeblock %}</p>

<p>
  <strong>Jbuilder</strong><br/>
  <a href="https://github.com/rails/jbuilder" target="_blank">jbuilder</a> provides a very similar DSL to RABL. Jbuilder is included with Rails, so it is used quite a bit. Rails Casts has a free episode which goes into greater detail about Jbuilder. It's very easy to use and provides a lot of flexibility in defining exactly what attributes are included in and how the response is formatted and nested.
</p>


<p>{% codeblock app/views/message/show.json.jbuilder lang:ruby %}
json.content format_content(@message.content)
json.(@message, :created_at, :updated_at)</p>

<p>json.author do
  json.name @message.creator.name.familiar
  json.email_address @message.creator.email_address_with_name
  json.url url_for(@message.creator, format: :json)
end
{% endcodeblock %}</p>

<p>
  <strong>Grape Entity</strong><br/>
  <a href="https://github.com/intridea/grape-entity" target="_blank">Grape Entity</a> was extracted from Grape, which is a popular gem used for building RESTful APIs. Similarly to RABL and Jbuilder, it provides a DSL for defining entities which are the structure of your JSON response.
</p>


<p>{% codeblock lang:ruby %}
module API
  module Entities</p>

<pre><code>class Status &lt; Grape::Entity
  expose :user_name
  expose :text, documentation: { type: "String", desc: "Status update text." }
  expose :ip, if: { type: :full }
  expose :user_type, :user_id, if: lambda { |status, options| status.user.public? }
  expose :contact_info do
    expose :phone
    expose :address, using: API::Address
  end
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  <strong>ROAR</strong><br/>
  <a href="https://github.com/apotonick/roar" target="_blank">ROAR</a> allows you to build presenter classes to represent your data. It comes with support for JSON, JSON-HAL, JSON-API, and XML.
</p>


<p>{% codeblock lang:ruby %}
require &lsquo;roar/json&rsquo;</p>

<p>module SongRepresenter
  include Roar::JSON
  property :title
end
{% endcodeblock %}</p>

<p>
  <strong>ActiveModel or Hash</strong><br/>
  This may seem like a strange thing to point out, but for very simple cases, you can simply call the to_json method on either an ActiveModel object or a native Ruby Hash.
</p>


<p>{% codeblock lang:ruby %}</p>

<h1>Using an @organization model</h1>

<p>respond_to do |format|
  format.json do</p>

<pre><code>render json: @organization.to_json
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock lang:ruby %}</p>

<h1>Using a plain Ruby Hash</h1>

<p>respond_to do |format|
  format.json do</p>

<pre><code>render json: {
  name: @user.name,
  email: @user.email
}.to_json
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Create QR Codes in Ruby on Rails Application]]></title>
    <link href="http://geekhmer.github.io/blog/2015/04/15/create-qr-codes-in-ruby-on-rails-application/"/>
    <updated>2015-04-15T11:34:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/04/15/create-qr-codes-in-ruby-on-rails-application</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" alt="Create QR Codes in Ruby on Rails Application" />
</p>




<p>
  <a href="https://rubygems.org/gems/barby" target="_blank">Barby</a> is a great gem for generating a barcode or QR code. You can choose to output it as any number of barcode types or as a QR code. This example will use a QR code but I have successfully used the Code128 barcode which is fairly common in the retail space.
</p>




<p>
  Add Barby to your gem file:
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &lsquo;barby&rsquo;,  &lsquo;~> 0.6.2&rsquo;
gem &lsquo;rqrcode&rsquo;,&lsquo;~> 0.4.2&rsquo;
{% endcodeblock %}</p>

<p>
  Here is an example helper for generating the QR code as base64 encoded png data:
</p>


<p>{% codeblock lang:ruby %}
def generate_qr(text)
  require &lsquo;barby&rsquo;
  require &lsquo;barby/barcode&rsquo;
  require &lsquo;barby/barcode/qr_code&rsquo;
  require &lsquo;barby/outputter/png_outputter&rsquo;</p>

<p>  barcode = Barby::QrCode.new(text, level: :q, size: 5)
  base64_output = Base64.encode64(barcode.to_png({ xdim: 5 }))
  &ldquo;data:image/png;base64,#{base64_output}&rdquo;
end
{% endcodeblock %}</p>

<p>
  And an example call from your view:
</p>


<p>{% codeblock lang:ruby %}
%img{src: generate_qr(&ldquo;<a href="http://geekhmer.github.io/">http://geekhmer.github.io/</a>&rdquo;), class: &ldquo;qr-code&rdquo;}
{% endcodeblock %}</p>

<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Translate Your Ruby on Rails Application]]></title>
    <link href="http://geekhmer.github.io/blog/2015/04/15/translate-your-ruby-on-rails-application/"/>
    <updated>2015-04-15T08:58:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/04/15/translate-your-ruby-on-rails-application</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" alt="Translate Your Ruby on Rails Application" />
</p>




<p>
  If you're planning to take over the world, you'll need to convince everyone to speak your language, or better yet, why don't you offer them a website that speaks their language. The goal is to have a website available in multiple languages, and for the visitors to be able to toggle over to the language they are most comfortable with.
</p>




<p>
  <strong>Routing</strong><br/>
  I like to nest all of my routes inside of a :locale scope. I also limit the locale options to a set that I have predefined in an initializer. You could also choose to deal with locale validity later on in the flow (before_action method), but it is up to you.
</p>


<p>{% codeblock config/routes.rb lang:ruby %}
scope &ldquo;(:locale)&rdquo;, locale: /#{MySite::ROUTE_LOCALES.keys.join(&ldquo;|&rdquo;)}/ do
  root :to => &lsquo;home#index&rsquo;
  resources :pages
  # etc&hellip;
end
{% endcodeblock %}</p>

<p>{% codeblock onfig/initializers/my_site.rb lang:ruby %}
module MySite
end</p>

<p>MySite::LOCALES = {
  en:    &ldquo;English&rdquo;,
  kh:    &ldquo;Khmer&rdquo;,
  fr:    &ldquo;French&rdquo;,
  en_us: &ldquo;US English&rdquo;,
  en_uk: &ldquo;UK English&rdquo;,
}</p>

<p>MySite::ROUTE_LOCALES = MySite::LOCALES.keys.each_with_object({}) do |locale, hsh|
  hsh[locale.to_s.tr(&ldquo;_&rdquo;,&ldquo;&ndash;&rdquo;)] = locale if locale.to_s.length > 2
end
{% endcodeblock %}</p>

<p>
  This line of code will make sure all of your routes have the current locale in them.
</p>


<p>{% codeblock app/controllers/application_controller.rb lang:ruby %}
def default_url_options(options={})
  { locale: I18n.locale }.merge(options)
end
{% endcodeblock %}</p>

<p>
  <strong>Determining Locale</strong><br/>
  I usually have a before_action filter which does its best to determine the URL of the application. You might have other things in here too if you keep track of the preferred locale in a cookie, or if it is attached to the user's session data or account. You may also want to use the HTTP_ACCEPT_LANGUAGE to determine if there is a match.
</p>


<p>{% codeblock app/controllers/application_controller.rb lang:ruby %}
class ApplicationController &lt; ActionController::Base
  before_action :determine_locale</p>

<p>  protected</p>

<p>  def determine_locale</p>

<pre><code>locale = if params.include?(:new_locale) &amp;&amp; MySite::ROUTE_LOCALES.keys.include?(params[:new_locale])
  params[:new_locale]
elsif params.include?(:locale)
  params[:locale]
else
  locale_from_url(request.host) || I18n.default_locale
end

set_locale(locale)
</code></pre>

<p>  end</p>

<p>  def locale_from_url(host)</p>

<pre><code># ... determine locale from host if you have different domains
# for different locales
</code></pre>

<p>  end</p>

<p>  def set_locale(locale)</p>

<pre><code>I18n.locale = locale.to_s.gsub("-","_").to_sym
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  <strong>Static Text</strong><br/>
  The developers should be entering their keys into the yml files located in the locales folder if your rails application. I normally only have one for English, and then use other I18n backends (Redis for example) serve up the other translations. If the translations are in Redis, you will obviously need code that puts them there. I am working on an engine for this called <a href="https://github.com/leighhalliday/idioma" target="_blank">Idioma</a> which persists the translations using ActiveRecord and also to Redis at the same time.
</p>




<p>
  <strong>Dynamic Content</strong><br/>
  Because I18n comes built in to Rails, you won't need to install many gems. But for dynamic content I recommend <a href="https://github.com/globalize/globalize" target="_blank">Globalize</a>. Along with this one is a handy gem called <a href="https://rubygems.org/gems/globalize-accessors" target="_blank">Globalize Accessors</a> which will help you when creating forms to enter this data in.
</p>


<p>{% codeblock lang:ruby %}
class Page &lt; ActiveRecord::Base
  translates :title, :body, fallbacks_for_empty_translations: true
  globalize_accessors locales: MySite::LOCALES.keys, attributes: [:title, :body]
end
{% endcodeblock %}</p>

<p>
  <strong>Dynamic Content</strong><br/>
  One thing I set up are fallbacks... this is so you can translate English once, and only when there is a locale that differs from the default do you need to specifically translate it for that locale. Example, in the US colour is spelled like color.
</p>


<p>{% codeblock config/application.rb lang:ruby %}
config.i18n.default_locale = :en_ca
config.i18n.fallbacks = {
  en_us: :en,
  kh   : :kh,
  en_uk: :en,
  fr_lu: :fr,
}
{% endcodeblock %}</p>

<p>
  <strong>Having Your Website Translated</strong><br/>
  Because the translation team probably isn't the same as the dev team, and they probably don't have access to your code repository nor know how to edit yml files, you will want to have another way of giving them access to the translations. There is an established tool called <a href="https://github.com/tolk/tolk" target="_blank">Tolk</a>.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby on Rails Model Generator Useful Shortcuts]]></title>
    <link href="http://geekhmer.github.io/blog/2015/04/13/ruby-on-rails-model-generator-useful-shortcuts/"/>
    <updated>2015-04-13T13:11:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/04/13/ruby-on-rails-model-generator-useful-shortcuts</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" alt="Ruby on Rails Renaming a Database Column" />
</p>




<p>
  <code>rails generate</code> command provides a lot of useful functionality, however some of it may not be immediately known to you as a developer. In this article we will explore a number of useful shortcuts available in the rails model generator.
</p>




<h3>Basics</h3>




<p>
  Let's start with the basic command line usage.
</p>


<p>{% codeblock lang:ruby %}
rails g model User
{% endcodeblock %}</p>

<p>
  <code>rails g</code> is the same thing as rails generate. Both commands do the same thing. We will use this shortcut throughout this article.
</p>


<p>{% codeblock lang:ruby %}
rails g model Product name quantity:integer
{% endcodeblock %}</p>

<p>
  This command generates a model named product with 2 fields, name, which is a string, and quantity, which is an integer. By not specifying the type for name, rails defaults to using string. Below is a complete list of types that you can use with the modal generator.
</p>




<p>
  <strong>Field Type Lists</strong><br/>
  - integer<br/>
  - primary_key<br/>
  - decimal<br/>
  - float<br/>
  - boolean<br/>
  - binary<br/>
  - string<br/>
  - text<br/>
  - date<br/>
  - time<br/>
  - datetime<br/>
  - timestamp
</p>




<p>
  You can also specify the size of a field as seen below.
</p>


<p>{% codeblock lang:ruby %}
rails g model Client name:string{ 100 }
{% endcodeblock %}</p>

<p>
  This will create a name field with a limit of 100 characters. For the decimal type, you can specify a precision and scale value as well.
</p>


<p>{% codeblock lang:ruby %}
rails g model Product name price:decimal{ 12, 2 }
{% endcodeblock %}</p>

<p>
  <strong>Namespaced Models</strong><br/>
  You can create namespaced models as well. This is useful for example, in creating a special set of administrative users that are separate from your regular users. Running the command below will place the user model in the Admin namespace, which will have a prefixed table name of admin_ in the database.
</p>


<p>{% codeblock lang:ruby %}
rails g model admin/user
{% endcodeblock %}</p>

<p>
  As you can see from the code listed below, the user belongs to the admin namespace like mentioned earlier.
</p>


<p>{% codeblock app/models/admin/user.rb lang:ruby %}
class Admin::User &lt; ActiveRecord::Base
end
{% endcodeblock %}</p>

<p>
  <strong>Adding an Index</strong><br/>
  You can also add a database index right from the command line.
</p>


<p>{% codeblock lang:ruby %}
rails g model Site name:string:index
{% endcodeblock %}</p>

<p>
  In addition, you can make the index unique.
</p>


<p>{% codeblock lang:ruby %}
rails g model Client name:string:uniq
{% endcodeblock %}</p>

<h3>Model Relationships</h3>




<p>
  You can specify a basic relationship between models.
</p>


<p>{% codeblock lang:ruby %}
rails g model User client:references
{% endcodeblock %}</p>

<p>
  This will create a user with a column named client_id, add an index, and automatically add a belongs_to relationship to the User model.
</p>




<p>
  You can also make the relationship polymorphic.
</p>


<p>{% codeblock lang:ruby %}
rails g model picture imageable:references{ polymorphic }
{% endcodeblock %}</p>

<p>
  This will set up a polymorphic relationship for pictures. Polymorphic relationships allow you to 'share' a table between many different models. For instance, Products and People can both have pictures.
</p>




<p>
  The rails model generator exposes a lot of useful functionality that can save time if used properly. Thanks for reading!
</p>

]]></content>
  </entry>
  
</feed>
