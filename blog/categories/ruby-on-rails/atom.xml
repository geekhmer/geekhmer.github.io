<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-05-05T15:31:30+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Send Notifications from Rails Backend to iOS and Android]]></title>
    <link href="http://geekhmer.github.io/blog/2016/05/03/send-notifications-from-rails-backend-to-ios-and-android/"/>
    <updated>2016-05-03T12:29:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/05/03/send-notifications-from-rails-backend-to-ios-and-android</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/gcm-app.png" width="600" alt="Send Notifications from Rails Backend to iOS and Android" />
</p>




<p>
  Written for a project. I developed the backend for a social network app - My own startup business, will release soon.
</p>




<p>
  One of the most common uses for a backend connected to a mobile application is to use it to send push notifications to users. Once you've wrapped your head around it, it's pretty straightforward, but it's also a common source of confusion for developers new to the topic. This frequent confusion is also the reason I've decided to cover it for my introductory technical story for my own startup business app, where I'm a CEO.
</p>




<p>
  Before I continue, you should know that there are plug-n-play services that will provide you with a notification-sending backend, if you're willing to pay for it (Parse, mobDB, Pushwoosh, Urban Airship, etc.), but since that's not the way of the warrior, let's see how you do it from scratch (and for free).
</p>


<p>{% blockquote %}
&ldquo;If you wish to make an apple pie from scratch, you must first invent the universe.&rdquo; &ndash; Carl Sagan
{% endblockquote %}</p>

<p>
  There are several components in my own startup business app that play various roles in the notification sending feature:<br/>
  1. API endpoint for getting tokens from mobile devices.<br/>
  2. <a href="https://github.com/resque/resque" target="_blank">Resque</a> worker which remains connected to Apple/Google notification servers and feeds off a queue of notifications in Redis.<br/>
  3. The code that does the actual sending and feedback processing in the worker.
</p>




<p>
  Before anything else, you need to ask the user if they'd like to receive push notifications (<a href="https://developer.apple.com/notifications/" target="_blank">iOS notifications</a>, <a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank">Google Cloud Messaging</a>) and if they say yes, get their device token and send it from the mobile device to the backend server. We store these tokens in a simple <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html" target="_blank">ActiveRecord</a> model called Device:
</p>


<p>{% codeblock lang:ruby %}</p>

<h1>====================</h1>

<h1>Schema Information</h1>

<h1>Table name: devices</h1>

<h1>id         :integer          not null, primary key</h1>

<h1>user_id    :integer</h1>

<h1>token      :string(255)</h1>

<h1>enabled    :boolean          default(TRUE)</h1>

<h1>created_at :datetime         not null</h1>

<h1>updated_at :datetime         not null</h1>

<h1>platform   :string(255)</h1>

<h1>====================</h1>

<p>class Device &lt; ActiveRecord::Base<br/>
  attr_accessible :enabled, :token, :user, :platform
  belongs_to :user
  validates_uniqueness_of :token, scope: :user_id
end
{% endcodeblock %}</p>

<p>
  Instances of Device get created when the mobile app calls an API endpoint, which looks something like this (we're using <a href="https://github.com/ruby-grape/grape" target="_blank">grape</a> gem for our API needs):
</p>


<p>{% codeblock lang:ruby %}
resource :devices do<br/>
  post do</p>

<pre><code>@device = Device.create(user: current_user, token: params[:token], platform: params[:platform])
present @device, with: WellWithMe::Entities::Device
</code></pre>

<p>  end
end<br/>
{% endcodeblock %}</p>

<p>
  With our mobile app user having a stored device token, we're now ready to queue notifications for her, which we do through a simple Redis list backed Notification model, which ensures data validity among other things. If a user has multiple devices, the Notification model also ensures they get sent to all of them. Queuing notifications is then as easy as:
</p>


<p>{% codeblock lang:ruby %}
notification = Notification.new(user, &ldquo;#{activity.user.name} just started the challenge!&rdquo;, &lsquo;status_change&rsquo;)
{% endcodeblock %}</p>

<p>
  In an essence, the Notification model is a Redis list, which serves as the queue for a background worker (NotificationSender):
</p>


<p>{% codeblock lang:ruby %}
class NotificationSender
  @queue = :notifications</p>

<p>  def self.perform</p>

<pre><code>@list = Redis::List.new(Notification.key_name)
while notification = @list.pop do
  notification_json = JSON.parse(notification)
  if notification_json['platform'] == 'iOS'
    note = Grocer::Notification.new(
      device_token: notification_json['token'],
      alert: notification_json['message'],
      sound: 'default',
      badge: 0
    )

    PUSHER.push(note)
  elsif notification_json['platform'] == 'Android'
    gcm = GCM.new(ENV['gcm_key'])
    registration_id = [notification_json['token']]
    options = {
      'data' =&gt; {
        'message' =&gt; notification_json['message']
      },
        'collapse_key' =&gt; 'updated_state'
    }
    response = gcm.send_notification(registration_id, options)
  end
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Having NotificationSender be a queued job constantly running on a worker as opposed to a synchronous connection has the advantage of not trying to establish a connection to Apple's notification servers for every notification, which is something Apple actively discourages: <a href="https://developer.apple.com/news/?id=03212012a" target="_blank">Apple's note about notification servers connections</a>.
</p>




<p>
  Thus NotificationSender is a Resque job, which is run every minute and just gobbles up the Redis list of notifications, and sends them according to the platform. We're using the awesome <a href="https://github.com/grocer/grocer" target="_blank">grocer</a> gem for iOS and the <a href="https://github.com/spacialdb/gcm" target="_blank">GCM</a> gem for Android. Both are working perfectly and the documentation is very good. The only caveat is that you should watch out for certificates magic in iOS, as you need to have your Apple certificates on the server as well, and you need to export them in a certain way (including the private key) - just follow instructions for the grocer gem to the letter, and you'll be fine.
</p>




<p>
  With this, you should have a working and easily extendible system for sending important notifications about in-app events to your users. Notifications can drastically increase user retention, just don't abuse them or they'll have an opposite effect.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Executing Background Tasks with Scheduler in Rails]]></title>
    <link href="http://geekhmer.github.io/blog/2016/03/04/executing-background-tasks-with-scheduler-in-rails/"/>
    <updated>2016-03-04T16:42:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/03/04/executing-background-tasks-with-scheduler-in-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Executing Background Tasks with Scheduler in Rails" />
</p>




<p>
  <a href="https://rubygems.org/gems/rufus-scheduler/versions/3.2.0" target="_blank">rufus-scheduler</a> is a handy gem that allows you to perform background jobs. In this article we will show you how to use rufus-scheduler in your Rails applications. Let's get started:
</p>




<h3>Setup</h3>




<p>
  In order to use rufus-scheduler, we must first add the rufus-scheduler gem to our Gemfile. To do this, open up your Gemfile and add in the line listed below:
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &lsquo;rufus-scheduler&rsquo;
{% endcodeblock %}</p>

<p>
  Run a bundle install to install the gem:
</p>


<p>{% codeblock lang:ruby %}
bundle install
{% endcodeblock %}</p>

<p>
  Great, we need to create an initializer that will contain the jobs we wish to schedule. Create a new initializer called scheduler.rb in the <code>config/initializers</code> directory and add in the code listed below:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
require &lsquo;rufus-scheduler&rsquo;</p>

<p>scheduler = Rufus::Scheduler::singleton</p>

<h1>jobs go below here.</h1>

<p>{% endcodeblock %}</p>

<p>
  Now we are ready to schedule jobs.
</p>




<h3>Scheduling the Jobs</h3>




<p>
  rufus-scheduler provides a simple syntax for scheduling jobs. You can schedule both one time jobs and recurring jobs. One time jobs can be either scheduled at a specific time, or you can tell rufus to wait a specific amount of time before running the job (a delayed job). For recurring jobs and delayed jobs, you can either use a simple plain English (30m = 30 minutes, etc.) format or you can use the cron format for scheduling jobs. For this article we'll focus on the English format:
</p>




<p>
  <strong>Recurring the Jobs</strong><br/>
  Scheduling recurring jobs is easy. Simply use the following format in your scheduler.rb file:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.every &lsquo;5s&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  The code above would perform your background task every 5 seconds. The list below will give you an idea of what time units are supported:
</p>




<p>
  <strong>s</strong> Example: 5s - seconds, specifies the number of seconds you wish to wait.<br/>
  <strong>m</strong> Example: 5m - the number of minutes you wish to wait.<br/>
  <strong>h</strong> Example: 5h - the number of hours you wish to wait.<br/>
  <strong>d</strong> Example: 5d - the number of days you wish to wait.<br/>
  <strong>w</strong> Example: 5w - the number of weeks you wish to wait.<br/>
  <strong>M</strong> Example: 5M - the number of months you wish to wait.<br/>
  <strong>y</strong> Example: 1y - the number of years you wish to wait.
</p>




<p>
  For example, the following code would tell rufus you wish to schedule a job for every 11 and a half hours:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.every &lsquo;11h30m&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  Scheduling a delayed job is easy. The syntax is similar to the recurring syntax listed above, but we use the <code>.in</code> method instead of <code>.every</code>. For example, the following code would run a task 4 hours after the server starts:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.in &lsquo;4h&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  <strong>Scheduling the Jobs for Specific Dates/Times</strong><br/>
  You can also schedule a job for a specific date and time. To do this we use the at method. For example, the following code would run at 12:01am on December 1st, 2017:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.at &lsquo;2017/12/01 00:01:00&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<h3>Important Caveats</h3>




<p>
  1. Because rufus-scheduler runs in process, the scheduler will reset if your Rails server gets restarted. This means that the timer for your jobs will get reset, so don't count on any monthly or yearly jobs getting called. If you need to persist jobs across server resets, use a job backend. We will show you how to do this in another article.<br/>
  2. Rufus does not work with Active Job.<br/>
  3. Some additional setup is needed for production environments (see below).
</p>




<h3>Production Setup</h3>




<p>
  Production servers require a bit of additional setup. On most production web servers, idle Ruby processes are killed. In order for rufus to work, you'll need to stop this from happening. For Passenger/Nginx you can copy the following code below to your <code>nginx.conf</code> config file for your website after the line that says <code>passenger_enabled on;</code>.
</p>


<p>{% codeblock nginx.conf lang:ruby %}
passenger_spawn_method direct;
passenger_min_instances 1;
passenger_pool_idle_time 0;
{% endcodeblock %}</p>

<p>
  rufus-scheduler is a simple, easy to use scheduler that provides great functionality. It can be used for stuff like sending emails, cleaning up temp files, and much more.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sessions Expiring]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/23/sessions-expiring/"/>
    <updated>2016-02-23T14:54:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/23/sessions-expiring</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Sessions Expiring" />
</p>




<p>
  To improve user security, we may wish to expire the user's session after they are inactive for a given amount of time. In order to do this, we simply set the <code>expire_after</code> parameter when setting up our session store. For example:
</p>


<p>{% codeblock config/initializers/session_store.rb lang:ruby %}
Rails.application.config.session_store :cookie_store, key: &lsquo;_example_session&rsquo;, expire_after: 15.minutes
{% endcodeblock %}</p>

<p>
  The line above would expire the session after 15 minutes of inactivity. This means that the user's session variables would get wiped once time reaches 15 minutes since the user last accessed the Rails application. If the user refreshes the page, the timer gets refreshed.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Flash Messages Styles]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/10/rails-flash-messages-styles/"/>
    <updated>2016-02-10T10:57:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/10/rails-flash-messages-styles</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Rails Flash Messages Styles" />
</p>




<p>
  If you're using Ruby on Rails with Twitter Bootstrap or other css framworks, then you may want to display flash messages with the alert styles. Here is a quick and easy way of doing so.
</p>




<p>
  You just need to quickly extend <code>application_helper.rb</code> with the following:
</p>


<p>{% codeblock application_helper.rb lang:ruby %}
module ApplicationHelper
  def bootstrap_class_for(flash_type)</p>

<pre><code>case flash_type
  when "success"
    "alert-success"
  when "error"
    "alert-danger"
  when "alert"
    "alert-warning"
  when "notice"
    "alert-info"
  else
    flash_type.to_s
  end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Now when you call a flash message, you can use the following in your view:
</p>


<p>{% codeblock lang:ruby %}
&lt;% flash.each do |type, message| %>
  <div class="alert <%= bootstrap_class_for(type) %> alert-dismissible" role=&ldquo;alert&rdquo;></p>

<pre><code>&lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
&lt;%= message %&gt;
</code></pre>

<p>  </div>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  And just use:
</p>


<p>{% codeblock lang:ruby %}
flash[:success] = &ldquo;Credit card type saved successfully!&rdquo;
{% endcodeblock %}</p>

<p>
  As success message:
</p>


<p>{% codeblock lang:ruby %}
flash[:alert] = &ldquo;Alerting you to the monkey on your car!&rdquo;
{% endcodeblock %}</p>

<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Model View Controller]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/01/rails-model-view-controller/"/>
    <updated>2016-02-01T15:33:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/01/rails-model-view-controller</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rails_mvc.png" width="500" alt="Rails Model View Controller" />
</p>




<p>
  The <strong>browser</strong> makes a request, such as http://geekhmer.com/video/show/15
</p>




<p>
  The <strong>web server</strong> (mongrel, WEBrick, etc.) receives the request. It uses routes to find out which controller to use: the default route pattern is <code>/controller/action/id</code> as defined in <code>config/routes.rb</code>. In our case, it’s the "video" controller, method "show", id "15". The web server then uses the dispatcher to create a new controller, call the action and pass the parameters.
</p>




<p>
  <strong>Controllers</strong> do the work of parsing user requests, data submissions, cookies, sessions and the "browser stuff". They’re the pointy-haired manager that orders employees around. The best controller is Dilbert-esque: It gives orders without knowing (or caring) how it gets done. In our case, the show method in the video controller knows it needs to lookup a video. It asks the model to get video 15, and will eventually display it to the user.
</p>


<p></p>

<p>
  <strong>Models</strong> are Ruby classes. They talk to the database, store and validate data, perform the business logic and otherwise do the heavy lifting. They’re the chubby guy in the back room crunching the numbers. In this case, the model retrieves video 15 from the database.
</p>




<p>
  <strong>Views</strong> are what the user sees: HTML, CSS, XML, Javascript, JSON. They’re the sales rep putting up flyers and collecting surveys, at the manager’s direction. Views are merely puppets reading what the controller gives them. They don’t know what happens in the back room. In our example, the controller gives video 15 to the "show" view. The show view generates the HTML: divs, tables, text, descriptions, footers, etc.
</p>




<p>
  The controller returns the response body (HTML, XML, etc.) & metadata (caching headers, redirects) to the server. The server combines the raw data into a proper HTTP response and sends it to the user.
</p>




<p>
  It’s more fun to imagine a story with "fat model, skinny controller" instead of a sterile "3-tiered architecture". Models do the grunt work, views are the happy face, and controllers are the masterminds behind it all.
</p>




<p>
  Many MVC discussions ignore the role of the web server. However, it’s important to mention how the controller magically gets created and passed user information. The web server is the invisible gateway, shuttling data back and forth: users never interact with the controller directly.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
