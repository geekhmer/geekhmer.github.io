<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-02-26T11:48:35+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sessions Expiring]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/23/sessions-expiring/"/>
    <updated>2016-02-23T14:54:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/23/sessions-expiring</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Sessions Expiring" />
</p>




<p>
  To improve user security, we may wish to expire the user's session after they are inactive for a given amount of time. In order to do this, we simply set the <code>expire_after</code> parameter when setting up our session store. For example:
</p>


<p>{% codeblock config/initializers/session_store.rb lang:ruby %}
Rails.application.config.session_store :cookie_store, key: &lsquo;_example_session&rsquo;, expire_after: 15.minutes
{% endcodeblock %}</p>

<p>
  The line above would expire the session after 15 minutes of inactivity. This means that the user's session variables would get wiped once time reaches 15 minutes since the user last accessed the Rails application. If the user refreshes the page, the timer gets refreshed.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Flash Messages Styles]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/10/rails-flash-messages-styles/"/>
    <updated>2016-02-10T10:57:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/10/rails-flash-messages-styles</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Rails Flash Messages Styles" />
</p>




<p>
  If you're using Ruby on Rails with Twitter Bootstrap or other css framworks, then you may want to display flash messages with the alert styles. Here is a quick and easy way of doing so.
</p>




<p>
  You just need to quickly extend <code>application_helper.rb</code> with the following:
</p>


<p>{% codeblock application_helper.rb lang:ruby %}
module ApplicationHelper
  def bootstrap_class_for(flash_type)</p>

<pre><code>case flash_type
  when "success"
    "alert-success"
  when "error"
    "alert-danger"
  when "alert"
    "alert-warning"
  when "notice"
    "alert-info"
  else
    flash_type.to_s
  end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Now when you call a flash message, you can use the following in your view:
</p>


<p>{% codeblock lang:ruby %}
&lt;% flash.each do |type, message| %>
  <div class="alert <%= bootstrap_class_for(type) %> alert-dismissible" role=&ldquo;alert&rdquo;></p>

<pre><code>&lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
&lt;%= message %&gt;
</code></pre>

<p>  </div>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  And just use:
</p>


<p>{% codeblock lang:ruby %}
flash[:success] = &ldquo;Credit card type saved successfully!&rdquo;
{% endcodeblock %}</p>

<p>
  As success message:
</p>


<p>{% codeblock lang:ruby %}
flash[:alert] = &ldquo;Alerting you to the monkey on your car!&rdquo;
{% endcodeblock %}</p>

<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Model View Controller]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/01/rails-model-view-controller/"/>
    <updated>2016-02-01T15:33:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/01/rails-model-view-controller</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rails_mvc.png" width="500" alt="Rails Model View Controller" />
</p>




<p>
  The <strong>browser</strong> makes a request, such as http://geekhmer.com/video/show/15
</p>




<p>
  The <strong>web server</strong> (mongrel, WEBrick, etc.) receives the request. It uses routes to find out which controller to use: the default route pattern is <code>/controller/action/id</code> as defined in <code>config/routes.rb</code>. In our case, it’s the "video" controller, method "show", id "15". The web server then uses the dispatcher to create a new controller, call the action and pass the parameters.
</p>




<p>
  <strong>Controllers</strong> do the work of parsing user requests, data submissions, cookies, sessions and the "browser stuff". They’re the pointy-haired manager that orders employees around. The best controller is Dilbert-esque: It gives orders without knowing (or caring) how it gets done. In our case, the show method in the video controller knows it needs to lookup a video. It asks the model to get video 15, and will eventually display it to the user.
</p>


<p></p>

<p>
  <strong>Models</strong> are Ruby classes. They talk to the database, store and validate data, perform the business logic and otherwise do the heavy lifting. They’re the chubby guy in the back room crunching the numbers. In this case, the model retrieves video 15 from the database.
</p>




<p>
  <strong>Views</strong> are what the user sees: HTML, CSS, XML, Javascript, JSON. They’re the sales rep putting up flyers and collecting surveys, at the manager’s direction. Views are merely puppets reading what the controller gives them. They don’t know what happens in the back room. In our example, the controller gives video 15 to the "show" view. The show view generates the HTML: divs, tables, text, descriptions, footers, etc.
</p>




<p>
  The controller returns the response body (HTML, XML, etc.) & metadata (caching headers, redirects) to the server. The server combines the raw data into a proper HTTP response and sends it to the user.
</p>




<p>
  It’s more fun to imagine a story with "fat model, skinny controller" instead of a sterile "3-tiered architecture". Models do the grunt work, views are the happy face, and controllers are the masterminds behind it all.
</p>




<p>
  Many MVC discussions ignore the role of the web server. However, it’s important to mention how the controller magically gets created and passed user information. The web server is the invisible gateway, shuttling data back and forth: users never interact with the controller directly.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Make Session Data Available to Models in Ruby on Rails?]]></title>
    <link href="http://geekhmer.github.io/blog/2016/01/27/how-to-make-session-data-available-to-models-in-ruby-on-rails/"/>
    <updated>2016-01-27T11:11:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/01/27/how-to-make-session-data-available-to-models-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="How to Make Session Data Available to Models in Ruby on Rails?" />
</p>




<p>
  Ruby on Rails is implemented as the Model View Controller (MVC) pattern. This pattern separates the context of the Web Application (in the Controller and the View) from the core Model of the application. The Model contains the Domain objects which encapsulate business logic, data retrieval, etc. The View displays information to the user and allows them to provide input to the application. The Controller handles the interactions between the View and the Model.
</p>




<p>
  This separation is a very good design principle that generally helps prevent <a href="https://en.wikipedia.org/wiki/Spaghetti_code" target="_blank">spaghetti code</a>. Sometimes though the separation might break down.
</p>




<p>
  Rails provides the Active Record Callbacks which allows you to write code that will respond to the lifecycle events of the Model objects. For example you could log information every time a specific kind of Model object is saved. For example you could record some information every time an Account changed using the following:
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  You might have noticed a limitation with the previous API though. You didn't notice? The only information passed to the model is the Object that is being changed. What if you want more context than this? For example, what if you want to audit not only the values that changed them, but the user who made the change?
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(current_user, self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  How do you get the <code>current_user</code> value? Well, you have to plan ahead a little bit. The User in this application is stored in the HTTP Session when the user is authenticated. The session isn't directly available to the Model level so you have to figure out a way around this. One way to accomplish this is by using a named <a href="http://ruby-doc.org/core-2.3.0/Thread.html#M000484" target="_blank">Thread local variable</a>. Each HTTP request is served by its own thread. That means that a variable stored as thread local will be available for the entire processing of a request.
</p>




<p>
  The UserInfo module encapsulates reading and writing the User object from/to the Thread local. This module can then be mixed in with other objects for easy access.
</p>


<p>{% codeblock user_info.rb lang:ruby %}
module UserInfo
  def current_user</p>

<pre><code>Thread.current[:user]
</code></pre>

<p>  end</p>

<p>  def self.current_user=(user)</p>

<pre><code>Thread.current[:user] = user
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  A <code>before_filter</code> set in the ApplicationController will be called before any action is called in any controller. You can take advantage of this to copy a value out of the HTTP session and set it in the Thread local:
</p>


<p>{% codeblock user_info.rb lang:ruby %}
class ApplicationController &lt; ActionController::Base
  before_filter :set_user</p>

<p>  protected
  def authenticate</p>

<pre><code>unless session[:user]
  redirect_to :controller =&gt; "login"
  return false
end
</code></pre>

<p>  end</p>

<p>  # Sets the current user into a named Thread location so that it can be accessed by models and observers
  def set_user</p>

<pre><code>UserInfo.current_user = session[:user]
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  At any point in a Model class that you need to have access to those values you can just mixin the helper module and then use its methods to access the data. In this final example we mixin the UserInfo module to our model and it will now have access to the <code>current_user</code> method:
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  include UserInfo</p>

<p>  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(current_user, self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  You generally shouldn't need this kind of trick outside of a model. In most cases the Controller should pass all of the information needed by a Model object to it through its methods. That will allow the Model objects to interact and the Controller to do the orchestration needed. But in a few special cases, this trick might be handy.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Tagging]]></title>
    <link href="http://geekhmer.github.io/blog/2016/01/26/rails-tagging/"/>
    <updated>2016-01-26T15:03:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/01/26/rails-tagging</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Rails Tagging" />
</p>




<p>
  For instance, in a social network, a user might have tags that are called skills, interests, sports, and more. This article will show you how to implement tagging in your Rails application. Let’s run through this with me.
</p>




<p>
  <strong>Installation</strong><br/>
  Add gem <code>acts-as-taggable-on</code> to your Gemfile:
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &lsquo;acts-as-taggable-on&rsquo;
{% endcodeblock %}</p>

<p>
  and run bundle:
</p>


<p>{% codeblock lang:ruby %}
bundle
{% endcodeblock %}</p>

<p>
  install migrations:
</p>


<p>{% codeblock lang:ruby %}
rails generate acts_as_taggable_on:migration
rake db:migrate
{% endcodeblock %}</p>

<p>
  This creates some tables and doesn't need to know anything specific about your models. The models and concerns for working with these tables (Tag, Tagging, etc).
</p>




<p>
  <strong>Model Integration</strong>
</p>


<p>{% codeblock app/models/post.rb lang:ruby %}
class Post
  acts_as_taggable
end
{% endcodeblock %}</p>

<p>
  Now you can do, eg:
</p>


<p>{% codeblock lang:ruby %}
post = Post.create
post.tag_list = &ldquo;programming, ruby, rails&rdquo;
post.tag_list</p>

<h1>=> [&lsquo;programming&rsquo;, &lsquo;ruby&rsquo;, &lsquo;rails&rsquo;]</h1>

<p>{% endcodeblock %}</p>

<p>
  <code>#tag_list=</code> takes a string and splits it up, using the resulting substrings to find_or_create Tags, and associate them with the taggable thing (eg, <code>Post</code>), through <code>Taggings</code>. You don't need to know this.
</p>




<p>
  The important thing is that, with <code>#tag_list=</code> we can manage tags via a comma-separated-list in a text field in a form.
</p>




<p>
  <strong>Controller Integration</strong>
</p>


<p>{% codeblock app/controllers/posts_controller.rb lang:ruby %}
class PostsController &lt; ApplicationController
  def create</p>

<pre><code>@post = Post.create(post_params)
redirect_to @post
</code></pre>

<p>  end</p>

<p>  def post_params</p>

<pre><code>params.require(:post).permit(:title, :body, :tag_list)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  This is assuming you're trying to tag an existing <code>Post</code> model with <code>title</code> and <code>body</code> fields, web-accessible through an existing <code>PostsController</code>, with <code>index</code>, <code>show</code>, <code>new</code>, etc. methods.
</p>




<p>
  Substitute your own, the important machinery here is whitelisting <code>tag_list</code> from the <code>params</code>.
</p>




<p>
  <strong>Form Integration</strong>
</p>


<p>{% codeblock app/views/posts/_form.html.erb lang:ruby %}
&lt;%= form_for post do |f| %>
  &lt;%= f.text_field :title %>
  &lt;%= f.text_area :body %>
  &lt;%= f.text_field :tag_list %>
  &lt;%= f.submit %>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  Now you can create tags for stuff. How about displaying them? Couple options, I'll go through the most explicit (a <code>TagsController</code> with index and show actions), but they can be rolled up into other controllers/actions.
</p>




<p>
  <strong>Controller</strong>
</p>


<p>{% codeblock config/routes.rb lang:ruby %}
Rails.application.routes.draw do
  resources :posts
  resources :tags, only: [:index, :show]
end
{% endcodeblock %}</p>

<p>{% codeblock app/controllers/tags_controller.rb lang:ruby %}
class TagsController &lt; ApplicationController
  def index</p>

<pre><code>@tags = ActsAsTaggableOn::Tag.all
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>@tag =  ActsAsTaggableOn::Tag.find(params[:id])
@posts = Post.tagged_with(@tag.name)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  It's unfortunate we have to do this slightly awkward workaround with <code>Post.tagged_with(@tag.name)</code> in <code>tags#show</code>. The <code>ActsAsTaggableOn::Tag</code> model does not have a built-in relationship with its taggable types (this is a necessary consequence of some polymorphism which we're not using here). We could add one for <code>Post</code>, but this way is easier to demonstrate.
</p>




<p>
  <strong>Tags Views</strong>
</p>


<p>{% codeblock app/views/acts_as_taggable_on/tags/_tag.html.erb lang:ruby %}
&lt;%= link_to tag.name, tag_path(tag) %>
{% endcodeblock %}</p>

<p>{% codeblock app/views/tags/index.html.erb lang:ruby %}</p>

<h1>Tags</h1>


<p>&lt;%= render @tags %>
{% endcodeblock %}</p>

<p>{% codeblock app/views/tags/show.html.erb lang:ruby %}</p>

<h1><%= @tag.name %></h1>


<div><%= render @posts %></div>


<p>{% endcodeblock %}</p>

<p>
  Note the partial path is <code>acts_as_taggable_on/tags/tag</code>. This is so we can just say <code>render @tags</code> and let rails do its implicit magic. There are other ways to organize everything, but this is the simplest.
</p>




<p>
  <strong>View Integration</strong>
</p>


<p>{% codeblock app/views/posts/_post.html.erb lang:ruby %}</p>

<h2><%= link_to post.title, post_path(post) %></h2>


<div><%= render post.tags %></div>


<p>{% endcodeblock %}</p>

<p>{% codeblock app/views/posts/index.html.erb lang:ruby %}</p>

<h1>Posts</h1>


<p>&lt;%= render @posts %>
{% endcodeblock %}</p>

<p>{% codeblock app/views/posts/show.html.erb lang:ruby %}</p>

<h1><%= @post.title %></h1>


<div><%= @post.body %></div>


<div><%= render @post.tags %></div>


<p>{% endcodeblock %}</p>

<p>
  And that should be it. It'll look shitty, but I hope you can figure out how to elaborate on this once you have it working. If anything here is assuming familiarity with something you don't have, ask and I will gladly elaborate.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
