<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-04-06T14:29:32+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Executing Background Tasks with Scheduler in Rails]]></title>
    <link href="http://geekhmer.github.io/blog/2016/03/04/executing-background-tasks-with-scheduler-in-rails/"/>
    <updated>2016-03-04T16:42:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/03/04/executing-background-tasks-with-scheduler-in-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Executing Background Tasks with Scheduler in Rails" />
</p>




<p>
  <a href="https://rubygems.org/gems/rufus-scheduler/versions/3.2.0" target="_blank">rufus-scheduler</a> is a handy gem that allows you to perform background jobs. In this article we will show you how to use rufus-scheduler in your Rails applications. Let's get started:
</p>




<h3>Setup</h3>




<p>
  In order to use rufus-scheduler, we must first add the rufus-scheduler gem to our Gemfile. To do this, open up your Gemfile and add in the line listed below:
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &lsquo;rufus-scheduler&rsquo;
{% endcodeblock %}</p>

<p>
  Run a bundle install to install the gem:
</p>


<p>{% codeblock lang:ruby %}
bundle install
{% endcodeblock %}</p>

<p>
  Great, we need to create an initializer that will contain the jobs we wish to schedule. Create a new initializer called scheduler.rb in the <code>config/initializers</code> directory and add in the code listed below:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
require &lsquo;rufus-scheduler&rsquo;</p>

<p>scheduler = Rufus::Scheduler::singleton</p>

<h1>jobs go below here.</h1>

<p>{% endcodeblock %}</p>

<p>
  Now we are ready to schedule jobs.
</p>




<h3>Scheduling the Jobs</h3>




<p>
  rufus-scheduler provides a simple syntax for scheduling jobs. You can schedule both one time jobs and recurring jobs. One time jobs can be either scheduled at a specific time, or you can tell rufus to wait a specific amount of time before running the job (a delayed job). For recurring jobs and delayed jobs, you can either use a simple plain English (30m = 30 minutes, etc.) format or you can use the cron format for scheduling jobs. For this article we'll focus on the English format:
</p>




<p>
  <strong>Recurring the Jobs</strong><br/>
  Scheduling recurring jobs is easy. Simply use the following format in your scheduler.rb file:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.every &lsquo;5s&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  The code above would perform your background task every 5 seconds. The list below will give you an idea of what time units are supported:
</p>




<p>
  <strong>s</strong> Example: 5s - seconds, specifies the number of seconds you wish to wait.<br/>
  <strong>m</strong> Example: 5m - the number of minutes you wish to wait.<br/>
  <strong>h</strong> Example: 5h - the number of hours you wish to wait.<br/>
  <strong>d</strong> Example: 5d - the number of days you wish to wait.<br/>
  <strong>w</strong> Example: 5w - the number of weeks you wish to wait.<br/>
  <strong>M</strong> Example: 5M - the number of months you wish to wait.<br/>
  <strong>y</strong> Example: 1y - the number of years you wish to wait.
</p>




<p>
  For example, the following code would tell rufus you wish to schedule a job for every 11 and a half hours:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.every &lsquo;11h30m&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  Scheduling a delayed job is easy. The syntax is similar to the recurring syntax listed above, but we use the <code>.in</code> method instead of <code>.every</code>. For example, the following code would run a task 4 hours after the server starts:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.in &lsquo;4h&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  <strong>Scheduling the Jobs for Specific Dates/Times</strong><br/>
  You can also schedule a job for a specific date and time. To do this we use the at method. For example, the following code would run at 12:01am on December 1st, 2017:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.at &lsquo;2017/12/01 00:01:00&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<h3>Important Caveats</h3>




<p>
  1. Because rufus-scheduler runs in process, the scheduler will reset if your Rails server gets restarted. This means that the timer for your jobs will get reset, so don't count on any monthly or yearly jobs getting called. If you need to persist jobs across server resets, use a job backend. We will show you how to do this in another article.<br/>
  2. Rufus does not work with Active Job.<br/>
  3. Some additional setup is needed for production environments (see below).
</p>




<h3>Production Setup</h3>




<p>
  Production servers require a bit of additional setup. On most production web servers, idle Ruby processes are killed. In order for rufus to work, you'll need to stop this from happening. For Passenger/Nginx you can copy the following code below to your <code>nginx.conf</code> config file for your website after the line that says <code>passenger_enabled on;</code>.
</p>


<p>{% codeblock nginx.conf lang:ruby %}
passenger_spawn_method direct;
passenger_min_instances 1;
passenger_pool_idle_time 0;
{% endcodeblock %}</p>

<p>
  rufus-scheduler is a simple, easy to use scheduler that provides great functionality. It can be used for stuff like sending emails, cleaning up temp files, and much more.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sessions Expiring]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/23/sessions-expiring/"/>
    <updated>2016-02-23T14:54:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/23/sessions-expiring</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Sessions Expiring" />
</p>




<p>
  To improve user security, we may wish to expire the user's session after they are inactive for a given amount of time. In order to do this, we simply set the <code>expire_after</code> parameter when setting up our session store. For example:
</p>


<p>{% codeblock config/initializers/session_store.rb lang:ruby %}
Rails.application.config.session_store :cookie_store, key: &lsquo;_example_session&rsquo;, expire_after: 15.minutes
{% endcodeblock %}</p>

<p>
  The line above would expire the session after 15 minutes of inactivity. This means that the user's session variables would get wiped once time reaches 15 minutes since the user last accessed the Rails application. If the user refreshes the page, the timer gets refreshed.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Flash Messages Styles]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/10/rails-flash-messages-styles/"/>
    <updated>2016-02-10T10:57:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/10/rails-flash-messages-styles</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Rails Flash Messages Styles" />
</p>




<p>
  If you're using Ruby on Rails with Twitter Bootstrap or other css framworks, then you may want to display flash messages with the alert styles. Here is a quick and easy way of doing so.
</p>




<p>
  You just need to quickly extend <code>application_helper.rb</code> with the following:
</p>


<p>{% codeblock application_helper.rb lang:ruby %}
module ApplicationHelper
  def bootstrap_class_for(flash_type)</p>

<pre><code>case flash_type
  when "success"
    "alert-success"
  when "error"
    "alert-danger"
  when "alert"
    "alert-warning"
  when "notice"
    "alert-info"
  else
    flash_type.to_s
  end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Now when you call a flash message, you can use the following in your view:
</p>


<p>{% codeblock lang:ruby %}
&lt;% flash.each do |type, message| %>
  <div class="alert <%= bootstrap_class_for(type) %> alert-dismissible" role=&ldquo;alert&rdquo;></p>

<pre><code>&lt;button type="button" class="close" data-dismiss="alert" aria-label="Close"&gt;&lt;span aria-hidden="true"&gt;&amp;times;&lt;/span&gt;&lt;/button&gt;
&lt;%= message %&gt;
</code></pre>

<p>  </div>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  And just use:
</p>


<p>{% codeblock lang:ruby %}
flash[:success] = &ldquo;Credit card type saved successfully!&rdquo;
{% endcodeblock %}</p>

<p>
  As success message:
</p>


<p>{% codeblock lang:ruby %}
flash[:alert] = &ldquo;Alerting you to the monkey on your car!&rdquo;
{% endcodeblock %}</p>

<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Model View Controller]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/01/rails-model-view-controller/"/>
    <updated>2016-02-01T15:33:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/01/rails-model-view-controller</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rails_mvc.png" width="500" alt="Rails Model View Controller" />
</p>




<p>
  The <strong>browser</strong> makes a request, such as http://geekhmer.com/video/show/15
</p>




<p>
  The <strong>web server</strong> (mongrel, WEBrick, etc.) receives the request. It uses routes to find out which controller to use: the default route pattern is <code>/controller/action/id</code> as defined in <code>config/routes.rb</code>. In our case, it’s the "video" controller, method "show", id "15". The web server then uses the dispatcher to create a new controller, call the action and pass the parameters.
</p>




<p>
  <strong>Controllers</strong> do the work of parsing user requests, data submissions, cookies, sessions and the "browser stuff". They’re the pointy-haired manager that orders employees around. The best controller is Dilbert-esque: It gives orders without knowing (or caring) how it gets done. In our case, the show method in the video controller knows it needs to lookup a video. It asks the model to get video 15, and will eventually display it to the user.
</p>


<p></p>

<p>
  <strong>Models</strong> are Ruby classes. They talk to the database, store and validate data, perform the business logic and otherwise do the heavy lifting. They’re the chubby guy in the back room crunching the numbers. In this case, the model retrieves video 15 from the database.
</p>




<p>
  <strong>Views</strong> are what the user sees: HTML, CSS, XML, Javascript, JSON. They’re the sales rep putting up flyers and collecting surveys, at the manager’s direction. Views are merely puppets reading what the controller gives them. They don’t know what happens in the back room. In our example, the controller gives video 15 to the "show" view. The show view generates the HTML: divs, tables, text, descriptions, footers, etc.
</p>




<p>
  The controller returns the response body (HTML, XML, etc.) & metadata (caching headers, redirects) to the server. The server combines the raw data into a proper HTTP response and sends it to the user.
</p>




<p>
  It’s more fun to imagine a story with "fat model, skinny controller" instead of a sterile "3-tiered architecture". Models do the grunt work, views are the happy face, and controllers are the masterminds behind it all.
</p>




<p>
  Many MVC discussions ignore the role of the web server. However, it’s important to mention how the controller magically gets created and passed user information. The web server is the invisible gateway, shuttling data back and forth: users never interact with the controller directly.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Make Session Data Available to Models in Ruby on Rails?]]></title>
    <link href="http://geekhmer.github.io/blog/2016/01/27/how-to-make-session-data-available-to-models-in-ruby-on-rails/"/>
    <updated>2016-01-27T11:11:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/01/27/how-to-make-session-data-available-to-models-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="How to Make Session Data Available to Models in Ruby on Rails?" />
</p>




<p>
  Ruby on Rails is implemented as the Model View Controller (MVC) pattern. This pattern separates the context of the Web Application (in the Controller and the View) from the core Model of the application. The Model contains the Domain objects which encapsulate business logic, data retrieval, etc. The View displays information to the user and allows them to provide input to the application. The Controller handles the interactions between the View and the Model.
</p>




<p>
  This separation is a very good design principle that generally helps prevent <a href="https://en.wikipedia.org/wiki/Spaghetti_code" target="_blank">spaghetti code</a>. Sometimes though the separation might break down.
</p>




<p>
  Rails provides the Active Record Callbacks which allows you to write code that will respond to the lifecycle events of the Model objects. For example you could log information every time a specific kind of Model object is saved. For example you could record some information every time an Account changed using the following:
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  You might have noticed a limitation with the previous API though. You didn't notice? The only information passed to the model is the Object that is being changed. What if you want more context than this? For example, what if you want to audit not only the values that changed them, but the user who made the change?
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(current_user, self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  How do you get the <code>current_user</code> value? Well, you have to plan ahead a little bit. The User in this application is stored in the HTTP Session when the user is authenticated. The session isn't directly available to the Model level so you have to figure out a way around this. One way to accomplish this is by using a named <a href="http://ruby-doc.org/core-2.3.0/Thread.html#M000484" target="_blank">Thread local variable</a>. Each HTTP request is served by its own thread. That means that a variable stored as thread local will be available for the entire processing of a request.
</p>




<p>
  The UserInfo module encapsulates reading and writing the User object from/to the Thread local. This module can then be mixed in with other objects for easy access.
</p>


<p>{% codeblock user_info.rb lang:ruby %}
module UserInfo
  def current_user</p>

<pre><code>Thread.current[:user]
</code></pre>

<p>  end</p>

<p>  def self.current_user=(user)</p>

<pre><code>Thread.current[:user] = user
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  A <code>before_filter</code> set in the ApplicationController will be called before any action is called in any controller. You can take advantage of this to copy a value out of the HTTP session and set it in the Thread local:
</p>


<p>{% codeblock user_info.rb lang:ruby %}
class ApplicationController &lt; ActionController::Base
  before_filter :set_user</p>

<p>  protected
  def authenticate</p>

<pre><code>unless session[:user]
  redirect_to :controller =&gt; "login"
  return false
end
</code></pre>

<p>  end</p>

<p>  # Sets the current user into a named Thread location so that it can be accessed by models and observers
  def set_user</p>

<pre><code>UserInfo.current_user = session[:user]
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  At any point in a Model class that you need to have access to those values you can just mixin the helper module and then use its methods to access the data. In this final example we mixin the UserInfo module to our model and it will now have access to the <code>current_user</code> method:
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  include UserInfo</p>

<p>  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(current_user, self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  You generally shouldn't need this kind of trick outside of a model. In most cases the Controller should pass all of the information needed by a Model object to it through its methods. That will allow the Model objects to interact and the Controller to do the orchestration needed. But in a few special cases, this trick might be handy.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
