<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2017-04-27T14:21:08+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Create content with multiple features with CKEditor Gem]]></title>
    <link href="http://geekhmer.github.io/blog/2017/01/05/create-content-with-multiple-features-with-ckeditor-gem/"/>
    <updated>2017-01-05T23:13:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2017/01/05/create-content-with-multiple-features-with-ckeditor-gem</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ckeditor.png" width="600" alt="Create content with multiple features with CKEditor Gem" />
</p>




<p>
  <strong>Setup & Usage</strong><br/>
  First, we need to add the CKEditor gem to our Gemfile. Open up your Gemfile and add the line listed below:
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &ldquo;ckeditor&rdquo;
{% endcodeblock %}</p>

<p>
  Next, open up the terminal and run a bundle install to install the gem:
</p>


<p>{% codeblock lang:ruby %}
bundle install
{% endcodeblock %}</p>

<p>
  Great, now lets create a sample model and accompanying controller that will be used to store our data. Open up and run the command below to create the Magazine model and migrate the database:
</p>


<p>{% codeblock lang:ruby %}
rails g resource Magazine title body:text
rake db:migrate
{% endcodeblock %}</p>

<p>
  Now, open your routes file and add the following line to your routes:
</p>


<p>{% codeblock routes.rb lang:ruby %}
root to: &ldquo;magazines#index&rdquo;
{% endcodeblock %}</p>

<p>
  Now, lets add the CKEditor javascript include to our application.js. Modify your application.js file so that it looks like the code listed below:
</p>


<p>{% codeblock application.js lang:ruby %}
// This is a manifest file that&rsquo;ll be compiled into application.js, which will include all the files
// listed below.
//
// Any JavaScript/Coffee file within this directory, lib/assets/javascripts, vendor/assets/javascripts,
// or any plugin&rsquo;s vendor/assets/javascripts directory can be referenced here using a relative path.
//
// It&rsquo;s not advisable to add code directly here, but if you do, it&rsquo;ll appear at the bottom of the
// compiled file. JavaScript code in this file should be added after the last require_* statement.
//
// Read Sprockets README (<a href="https://github.com/rails/sprockets#sprockets-directives">https://github.com/rails/sprockets#sprockets-directives</a>) for details
// about supported directives.
//
//= require jquery
//= require jquery_ujs
//= require ckeditor/init
//= require turbolinks
//= require_tree .
{% endcodeblock %}</p>

<p>
  Great, now we need to add some code to the magazines controller. Add the following code to the magazines controller:
</p>


<p>{% codeblock magazines_controller.rb lang:ruby %}
class MagazinesController &lt; ApplicationController
  def index</p>

<pre><code>@magazines = Magazine.order("created_at DESC")
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>@magazine = Magazine.find(params[:id])
</code></pre>

<p>  end</p>

<p>  def new</p>

<pre><code>@magazine = Magazine.new
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>@magazine = Magazine.new(magazine_params)
if @magazine.save
  redirect_to magazines_path, notice: "The magazines has been successfully created."
else
  render action: "new"
end
</code></pre>

<p>  end</p>

<p>  def edit</p>

<pre><code>@magazine = Magazine.find(params[:id])
</code></pre>

<p>  end</p>

<p>  def update</p>

<pre><code>@magazine = Magazine.find(params[:id])
if @magazine.update_attributes(magazine_params)
  redirect_to magazines_path, notice: "The magazine has been successfully updated."
else
  render action: "edit"
end
</code></pre>

<p>  end</p>

<p>  private
  def magazine_params</p>

<pre><code>params.require(:magazine).permit(:title, :body)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  This code enables the ability to read, write, and update the magazines in our example. Now for the views, first lets create the index view:
</p>


<p>{% codeblock index.html.erb lang:ruby %}
&lt;%= link_to &ldquo;New Magazine&rdquo;, new_magazine_path %>
&lt;% @magazines.each do |magazine| %>
  <h3>&lt;%= magazine.title.html_safe %></h3>
  <p>&lt;%= magazine.body.html_safe %></p>
  &lt;%= link_to &ldquo;Edit Magazine&rdquo;, edit_magazine_path(magazine) %>
  &lt;% if magazine != @magazines.last %>
  <hr />
  &lt;% end %>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  Now, lets create a partial to store the form. Create a file called app/views/_form.html.erb and add the code listed below:
</p>


<p>{% codeblock _form.html.erb lang:ruby %}
&lt;% if @magazine.errors.any? %>
  <ul></p>

<pre><code>&lt;%= @magazine.errors.full_messages.each do |message| %&gt;
    &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;
&lt;% end %&gt;
</code></pre>

<p>  </ul>
&lt;% end %>
&lt;%= form_for @magazine do |f| %>
  <div></p>

<pre><code>&lt;%= f.label :title %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= f.text_field :title %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= f.label :body %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= f.cktext_area :body, rows: 10 %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= f.submit %&gt;
</code></pre>

<p>  </div>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  Now, lets create the new view. Create the app/views/magazines/new.html.erb file and add the code listed below:
</p>


<p>{% codeblock new.html.erb lang:ruby %}</p>

<h3> New Magazine</h3>


<p>&lt;%= render &ldquo;form&rdquo; %>
{% endcodeblock %}</p>

<p>
  Now, if you visit the new magazines page on your development server you will see that CKEditor appears.
</p>




<p>
  Next lets create the edit view. Create the app/views/magazines/edit.html.erb file and add the code listed below:
</p>


<p>{% codeblock edit.html.erb lang:ruby %}
&lt;%= &ldquo;Editing #{@magazine.title}&rdquo; %>
&lt;%= render &ldquo;form&rdquo; %>
{% endcodeblock %}</p>

<p>
  Great, now when you click 'edit magazine' on any magazine, it will show the CKEditor for editing.
</p>




<p>
  <strong>Images Using Paperclip</strong><br/>
  In order to integrate images via paperclip, a few more steps are required. Note that you must have ImageMagick installed for this to work. First, lets include the paperclip gem:
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &ldquo;paperclip&rdquo;
{% endcodeblock %}</p>

<p>
  Next, we need to run a generator provided by ckeditor. This generator will create the necessary models that will be used to store image data. Run the command below:
</p>


<p>{% codeblock lang:ruby %}
rails generate ckeditor:install &mdash;orm=active_record &mdash;backend=paperclip
rake db:migrate
{% endcodeblock %}</p>

<p>
  So far so good, if you restart your rails server and refresh the page, you will be able to click the images button, upload an image, and insert it into your articles.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup and Deploy Ruby On Rails on Ubuntu 16.04 or Latest]]></title>
    <link href="http://geekhmer.github.io/blog/2016/07/13/setup-and-deploy-ruby-on-rails-on-ubuntu-16-dot-04-or-latest/"/>
    <updated>2016-07-13T15:00:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/07/13/setup-and-deploy-ruby-on-rails-on-ubuntu-16-dot-04-or-latest</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rails_nginx_ubuntu.jpg" width="600" alt="Setup and Deploy Ruby On Rails on Ubuntu 16.04 or Latest" />
</p>




<p>
  Since we setup Ubuntu for our development environment, we also want to use it in production. This keeps your application running consistently between development and production. 
</p>




<h3>Install Ruby</h3>




<p>
  The first step is to install some dependencies for Ruby:
</p>


<p>{% codeblock lang:ruby %}
sudo apt-get update
sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libffi-dev
{% endcodeblock %}</p>

<p>
  Next we're going to be installing Ruby using rvm:
</p>


<p>{% codeblock lang:ruby %}
sudo apt-get install libgdbm-dev libncurses5-dev automake libtool bison libffi-dev
gpg &mdash;keyserver hkp://keys.gnupg.net &mdash;recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3
curl -sSL <a href="https://get.rvm.io">https://get.rvm.io</a> | bash -s stable
source ~/.rvm/scripts/rvm
rvm install 2.3.1
rvm use 2.3.1 &mdash;default
ruby -v
{% endcodeblock %}</p>

<p>
  The last step is to install Bundler
</p>


<p>{% codeblock lang:ruby %}
gem install bundler
{% endcodeblock %}</p>

<h3>Install Nginx</h3>




<p>
  Phusion is the company that develops Passenger and they recently put out an official Ubuntu package that ships with Nginx and Passenger pre-installed.
</p>




<p>
  We'll be using that to setup our production server because it's very easy to setup:
</p>


<p>{% codeblock lang:ruby %}
sudo apt-key adv &mdash;keyserver hkp://keyserver.ubuntu.com:80 &mdash;recv-keys 561F9B9CAC40B2F7
sudo apt-get install -y apt-transport-https ca-certificates</p>

<h1>Add Passenger APT repository</h1>

<p>sudo sh -c &lsquo;echo deb <a href="https://oss-binaries.phusionpassenger.com/apt/passenger">https://oss-binaries.phusionpassenger.com/apt/passenger</a> xenial main > /etc/apt/sources.list.d/passenger.list&rsquo;
sudo apt-get update</p>

<h1>Install Passenger &amp; Nginx</h1>

<p>sudo apt-get install -y nginx-extras passenger
{% endcodeblock %}</p>

<p>So now we have Nginx and passenger installed. We can manage the Nginx webserver by using the service command:</p>


<p>{% codeblock lang:ruby %}
sudo service nginx start
{% endcodeblock %}</p>

<p>
The service command also provides some other methods such as <code>restart</code> and <code>stop</code> that allow you to easily restart and stop your webserver.
</p>




<p>Next, we need to update the Nginx configuration to point Passenger to the version of Ruby that we're using. You'll want to open up <code>/etc/nginx/nginx.conf</code> in your favorite editor. I like to use vim, so I'd run this command:</p>


<p>{% codeblock lang:ruby %}
sudo vim /etc/nginx/nginx.conf
{% endcodeblock %}</p>

<p>Find the following lines, and uncomment them:</p>


<p>{% codeblock lang:ruby %}</p>

<h1>#</h1>

<h1>Phusion Passenger config</h1>

<h1>#</h1>

<h1>Uncomment it if you installed passenger or passenger-enterprise</h1>

<h1>#</h1>

<p>include /etc/nginx/passenger.conf;
{% endcodeblock %}</p>

<p>Once you've configured <code>/etc/nginx/nginx.conf</code> , you can run <code>sudo service nginx restart</code> to restart Nginx with the new Passenger configuration.</p>




<h3>Install MySQL and PostgreSQL</h3>




<p>Setting up your production database is pretty easy. Make sure to keep in mind that you should use a different password for your production databases.</p>




<p>Depending on what database you want to use, follow the steps related to the database:</p>




<p>
  <strong>Install MySQL</strong><br/>
  All you need to do in order to install MySQL is to run the following command:
</p>


<p>{% codeblock lang:ruby %}
sudo apt-get install mysql-server mysql-client libmysqlclient-dev
{% endcodeblock %}</p>

<p>You can use the root user and password set during installation for your database or you can add a new user to MySQL.</p>




<p>
  <strong>Install PostgreSQL</strong><br/>
  We can install PostgreSQL like so:
</p>


<p>{% codeblock lang:ruby %}
sudo apt-get install postgresql postgresql-contrib libpq-dev
{% endcodeblock %}</p>

<p>Next we need to setup the postgres user:</p>


<p>{% codeblock lang:ruby %}
sudo su &ndash; postgres
createuser &mdash;pwprompt
exit
{% endcodeblock %}</p>

<p>The password you type in here will be the one to put in your <code>my_app/current/config/database.yml</code> later when you deploy your app for the first time.</p>




<h3>Adding The Nginx Host</h3>




<p>In order to get Nginx to respond with the Rails app, we need to modify it's sites-enabled.</p>




<p>Open up <code>/etc/nginx/sites-enabled/default</code> in your text editor and we will replace the file's contents with the following:</p>


<p>{% codeblock lang:ruby %}
server {
  listen 80 default_server;
  listen [::]:80 default_server ipv6only=on;</p>

<p>  server_name mydomain.com;
  passenger_enabled on;
  rails_env    production;
  root         /home/deploy/myapp/public;</p>

<p>  # redirect server error pages to the static page /50x.html
  error_page   500 502 503 504  /50x.html;
  location = /50x.html {</p>

<pre><code>root   html;
</code></pre>

<p>  }
}
{% endcodeblock %}</p>

<p>This is our Nginx configuration for a server listening on port 80. You need to change the server_name values to match the domain you want to use and in root replace "myapp" with the name of your application.</p>




<h3>Connect The Database</h3>




<p>
  The file <code>config/database.yml</code> needs to be updated for the production database server username, password, and host. You can set host to "localhost" and you will have to create a database on the server with the same name by using command:
</p>


<p>{% codeblock lang:ruby %}
rake db:create RAILS_ENV=production
rake db:migrate RAILS_ENV=production
{% endcodeblock %}</p>

<p>Then run command below to minify or compress JavaScript and CSS assets:</p>


<p>{% codeblock lang:ruby %}
rake assets:precompile RAILS_ENV=production
{% endcodeblock %}</p>

<h3>Setup Secret Key Base</h3>




<p>Go to your rails app directory and run command below to generate secret key base:</p>


<p>{% codeblock lang:ruby %}
rake secret RAILS_ENV=production
{% endcodeblock %}</p>

<p>
  Go to <code>/yourapp/config/secrets.yml</code> and set production secret_key_base. Then reload Nginx using command line: <code>sudo service nginx reload</code>
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Send Notifications from Rails Backend to iOS and Android]]></title>
    <link href="http://geekhmer.github.io/blog/2016/05/03/send-notifications-from-rails-backend-to-ios-and-android/"/>
    <updated>2016-05-03T12:29:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/05/03/send-notifications-from-rails-backend-to-ios-and-android</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/gcm-app.png" width="600" alt="Send Notifications from Rails Backend to iOS and Android" />
</p>




<p>
  Written for a project. I developed the backend for a social network app - My own startup business, will release soon.
</p>




<p>
  One of the most common uses for a backend connected to a mobile application is to use it to send push notifications to users. Once you've wrapped your head around it, it's pretty straightforward, but it's also a common source of confusion for developers new to the topic. This frequent confusion is also the reason I've decided to cover it for my introductory technical story for my own startup business app, where I'm a CEO.
</p>




<p>
  Before I continue, you should know that there are plug-n-play services that will provide you with a notification-sending backend, if you're willing to pay for it (Parse, mobDB, Pushwoosh, Urban Airship, etc.), but since that's not the way of the warrior, let's see how you do it from scratch (and for free).
</p>


<p>{% blockquote %}
&ldquo;If you wish to make an apple pie from scratch, you must first invent the universe.&rdquo; &ndash; Carl Sagan
{% endblockquote %}</p>

<p>
  There are several components in my own startup business app that play various roles in the notification sending feature:<br/>
  1. API endpoint for getting tokens from mobile devices.<br/>
  2. <a href="https://github.com/resque/resque" target="_blank">Resque</a> worker which remains connected to Apple/Google notification servers and feeds off a queue of notifications in Redis.<br/>
  3. The code that does the actual sending and feedback processing in the worker.
</p>




<p>
  Before anything else, you need to ask the user if they'd like to receive push notifications (<a href="https://developer.apple.com/notifications/" target="_blank">iOS notifications</a>, <a href="http://developer.android.com/guide/topics/ui/notifiers/notifications.html" target="_blank">Google Cloud Messaging</a>) and if they say yes, get their device token and send it from the mobile device to the backend server. We store these tokens in a simple <a href="http://api.rubyonrails.org/classes/ActiveRecord/Base.html" target="_blank">ActiveRecord</a> model called Device:
</p>


<p>{% codeblock lang:ruby %}</p>

<h1>====================</h1>

<h1>Schema Information</h1>

<h1>Table name: devices</h1>

<h1>id         :integer          not null, primary key</h1>

<h1>user_id    :integer</h1>

<h1>token      :string(255)</h1>

<h1>enabled    :boolean          default(TRUE)</h1>

<h1>created_at :datetime         not null</h1>

<h1>updated_at :datetime         not null</h1>

<h1>platform   :string(255)</h1>

<h1>====================</h1>

<p>class Device &lt; ActiveRecord::Base<br/>
  attr_accessible :enabled, :token, :user, :platform
  belongs_to :user
  validates_uniqueness_of :token, scope: :user_id
end
{% endcodeblock %}</p>

<p>
  Instances of Device get created when the mobile app calls an API endpoint, which looks something like this (we're using <a href="https://github.com/ruby-grape/grape" target="_blank">grape</a> gem for our API needs):
</p>


<p>{% codeblock lang:ruby %}
resource :devices do<br/>
  post do</p>

<pre><code>@device = Device.create(user: current_user, token: params[:token], platform: params[:platform])
present @device, with: WellWithMe::Entities::Device
</code></pre>

<p>  end
end<br/>
{% endcodeblock %}</p>

<p>
  With our mobile app user having a stored device token, we're now ready to queue notifications for her, which we do through a simple Redis list backed Notification model, which ensures data validity among other things. If a user has multiple devices, the Notification model also ensures they get sent to all of them. Queuing notifications is then as easy as:
</p>


<p>{% codeblock lang:ruby %}
notification = Notification.new(user, &ldquo;#{activity.user.name} just started the challenge!&rdquo;, &lsquo;status_change&rsquo;)
{% endcodeblock %}</p>

<p>
  In an essence, the Notification model is a Redis list, which serves as the queue for a background worker (NotificationSender):
</p>


<p>{% codeblock lang:ruby %}
class NotificationSender
  @queue = :notifications</p>

<p>  def self.perform</p>

<pre><code>@list = Redis::List.new(Notification.key_name)
while notification = @list.pop do
  notification_json = JSON.parse(notification)
  if notification_json['platform'] == 'iOS'
    note = Grocer::Notification.new(
      device_token: notification_json['token'],
      alert: notification_json['message'],
      sound: 'default',
      badge: 0
    )

    PUSHER.push(note)
  elsif notification_json['platform'] == 'Android'
    gcm = GCM.new(ENV['gcm_key'])
    registration_id = [notification_json['token']]
    options = {
      'data' =&gt; {
        'message' =&gt; notification_json['message']
      },
        'collapse_key' =&gt; 'updated_state'
    }
    response = gcm.send_notification(registration_id, options)
  end
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Having NotificationSender be a queued job constantly running on a worker as opposed to a synchronous connection has the advantage of not trying to establish a connection to Apple's notification servers for every notification, which is something Apple actively discourages: <a href="https://developer.apple.com/news/?id=03212012a" target="_blank">Apple's note about notification servers connections</a>.
</p>




<p>
  Thus NotificationSender is a Resque job, which is run every minute and just gobbles up the Redis list of notifications, and sends them according to the platform. We're using the awesome <a href="https://github.com/grocer/grocer" target="_blank">grocer</a> gem for iOS and the <a href="https://github.com/spacialdb/gcm" target="_blank">GCM</a> gem for Android. Both are working perfectly and the documentation is very good. The only caveat is that you should watch out for certificates magic in iOS, as you need to have your Apple certificates on the server as well, and you need to export them in a certain way (including the private key) - just follow instructions for the grocer gem to the letter, and you'll be fine.
</p>




<p>
  With this, you should have a working and easily extendible system for sending important notifications about in-app events to your users. Notifications can drastically increase user retention, just don't abuse them or they'll have an opposite effect.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Executing Background Tasks with Scheduler in Rails]]></title>
    <link href="http://geekhmer.github.io/blog/2016/03/04/executing-background-tasks-with-scheduler-in-rails/"/>
    <updated>2016-03-04T16:42:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/03/04/executing-background-tasks-with-scheduler-in-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Executing Background Tasks with Scheduler in Rails" />
</p>




<p>
  <a href="https://rubygems.org/gems/rufus-scheduler/versions/3.2.0" target="_blank">rufus-scheduler</a> is a handy gem that allows you to perform background jobs. In this article we will show you how to use rufus-scheduler in your Rails applications. Let's get started:
</p>




<h3>Setup</h3>




<p>
  In order to use rufus-scheduler, we must first add the rufus-scheduler gem to our Gemfile. To do this, open up your Gemfile and add in the line listed below:
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &lsquo;rufus-scheduler&rsquo;
{% endcodeblock %}</p>

<p>
  Run a bundle install to install the gem:
</p>


<p>{% codeblock lang:ruby %}
bundle install
{% endcodeblock %}</p>

<p>
  Great, we need to create an initializer that will contain the jobs we wish to schedule. Create a new initializer called scheduler.rb in the <code>config/initializers</code> directory and add in the code listed below:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
require &lsquo;rufus-scheduler&rsquo;</p>

<p>scheduler = Rufus::Scheduler::singleton</p>

<h1>jobs go below here.</h1>

<p>{% endcodeblock %}</p>

<p>
  Now we are ready to schedule jobs.
</p>




<h3>Scheduling the Jobs</h3>




<p>
  rufus-scheduler provides a simple syntax for scheduling jobs. You can schedule both one time jobs and recurring jobs. One time jobs can be either scheduled at a specific time, or you can tell rufus to wait a specific amount of time before running the job (a delayed job). For recurring jobs and delayed jobs, you can either use a simple plain English (30m = 30 minutes, etc.) format or you can use the cron format for scheduling jobs. For this article we'll focus on the English format:
</p>




<p>
  <strong>Recurring the Jobs</strong><br/>
  Scheduling recurring jobs is easy. Simply use the following format in your scheduler.rb file:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.every &lsquo;5s&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  The code above would perform your background task every 5 seconds. The list below will give you an idea of what time units are supported:
</p>




<p>
  <strong>s</strong> Example: 5s - seconds, specifies the number of seconds you wish to wait.<br/>
  <strong>m</strong> Example: 5m - the number of minutes you wish to wait.<br/>
  <strong>h</strong> Example: 5h - the number of hours you wish to wait.<br/>
  <strong>d</strong> Example: 5d - the number of days you wish to wait.<br/>
  <strong>w</strong> Example: 5w - the number of weeks you wish to wait.<br/>
  <strong>M</strong> Example: 5M - the number of months you wish to wait.<br/>
  <strong>y</strong> Example: 1y - the number of years you wish to wait.
</p>




<p>
  For example, the following code would tell rufus you wish to schedule a job for every 11 and a half hours:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.every &lsquo;11h30m&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  Scheduling a delayed job is easy. The syntax is similar to the recurring syntax listed above, but we use the <code>.in</code> method instead of <code>.every</code>. For example, the following code would run a task 4 hours after the server starts:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.in &lsquo;4h&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<p>
  <strong>Scheduling the Jobs for Specific Dates/Times</strong><br/>
  You can also schedule a job for a specific date and time. To do this we use the at method. For example, the following code would run at 12:01am on December 1st, 2017:
</p>


<p>{% codeblock config/initializers/scheduler.rb lang:ruby %}
scheduler.at &lsquo;2017/12/01 00:01:00&rsquo; do
  # do stuff
end
{% endcodeblock %}</p>

<h3>Important Caveats</h3>




<p>
  1. Because rufus-scheduler runs in process, the scheduler will reset if your Rails server gets restarted. This means that the timer for your jobs will get reset, so don't count on any monthly or yearly jobs getting called. If you need to persist jobs across server resets, use a job backend. We will show you how to do this in another article.<br/>
  2. Rufus does not work with Active Job.<br/>
  3. Some additional setup is needed for production environments (see below).
</p>




<h3>Production Setup</h3>




<p>
  Production servers require a bit of additional setup. On most production web servers, idle Ruby processes are killed. In order for rufus to work, you'll need to stop this from happening. For Passenger/Nginx you can copy the following code below to your <code>nginx.conf</code> config file for your website after the line that says <code>passenger_enabled on;</code>.
</p>


<p>{% codeblock nginx.conf lang:ruby %}
passenger_spawn_method direct;
passenger_min_instances 1;
passenger_pool_idle_time 0;
{% endcodeblock %}</p>

<p>
  rufus-scheduler is a simple, easy to use scheduler that provides great functionality. It can be used for stuff like sending emails, cleaning up temp files, and much more.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sessions Expiring]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/23/sessions-expiring/"/>
    <updated>2016-02-23T14:54:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/23/sessions-expiring</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Sessions Expiring" />
</p>




<p>
  To improve user security, we may wish to expire the user's session after they are inactive for a given amount of time. In order to do this, we simply set the <code>expire_after</code> parameter when setting up our session store. For example:
</p>


<p>{% codeblock config/initializers/session_store.rb lang:ruby %}
Rails.application.config.session_store :cookie_store, key: &lsquo;_example_session&rsquo;, expire_after: 15.minutes
{% endcodeblock %}</p>

<p>
  The line above would expire the session after 15 minutes of inactivity. This means that the user's session variables would get wiped once time reaches 15 minutes since the user last accessed the Rails application. If the user refreshes the page, the timer gets refreshed.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
