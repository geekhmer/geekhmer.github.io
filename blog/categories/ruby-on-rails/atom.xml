<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby on Rails | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby-on-rails/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-02-04T16:48:52+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rails Model View Controller]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/01/rails-model-view-controller/"/>
    <updated>2016-02-01T15:33:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/01/rails-model-view-controller</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rails_mvc.png" width="500" alt="Rails Model View Controller" />
</p>




<p>
  The <strong>browser</strong> makes a request, such as http://geekhmer.com/video/show/15
</p>




<p>
  The <strong>web server</strong> (mongrel, WEBrick, etc.) receives the request. It uses routes to find out which controller to use: the default route pattern is <code>/controller/action/id</code> as defined in <code>config/routes.rb</code>. In our case, it’s the "video" controller, method "show", id "15". The web server then uses the dispatcher to create a new controller, call the action and pass the parameters.
</p>




<p>
  <strong>Controllers</strong> do the work of parsing user requests, data submissions, cookies, sessions and the "browser stuff". They’re the pointy-haired manager that orders employees around. The best controller is Dilbert-esque: It gives orders without knowing (or caring) how it gets done. In our case, the show method in the video controller knows it needs to lookup a video. It asks the model to get video 15, and will eventually display it to the user.
</p>


<p></p>

<p>
  <strong>Models</strong> are Ruby classes. They talk to the database, store and validate data, perform the business logic and otherwise do the heavy lifting. They’re the chubby guy in the back room crunching the numbers. In this case, the model retrieves video 15 from the database.
</p>




<p>
  <strong>Views</strong> are what the user sees: HTML, CSS, XML, Javascript, JSON. They’re the sales rep putting up flyers and collecting surveys, at the manager’s direction. Views are merely puppets reading what the controller gives them. They don’t know what happens in the back room. In our example, the controller gives video 15 to the "show" view. The show view generates the HTML: divs, tables, text, descriptions, footers, etc.
</p>




<p>
  The controller returns the response body (HTML, XML, etc.) & metadata (caching headers, redirects) to the server. The server combines the raw data into a proper HTTP response and sends it to the user.
</p>




<p>
  It’s more fun to imagine a story with "fat model, skinny controller" instead of a sterile "3-tiered architecture". Models do the grunt work, views are the happy face, and controllers are the masterminds behind it all.
</p>




<p>
  Many MVC discussions ignore the role of the web server. However, it’s important to mention how the controller magically gets created and passed user information. The web server is the invisible gateway, shuttling data back and forth: users never interact with the controller directly.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to Make Session Data Available to Models in Ruby on Rails?]]></title>
    <link href="http://geekhmer.github.io/blog/2016/01/27/how-to-make-session-data-available-to-models-in-ruby-on-rails/"/>
    <updated>2016-01-27T11:11:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/01/27/how-to-make-session-data-available-to-models-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="How to Make Session Data Available to Models in Ruby on Rails?" />
</p>




<p>
  Ruby on Rails is implemented as the Model View Controller (MVC) pattern. This pattern separates the context of the Web Application (in the Controller and the View) from the core Model of the application. The Model contains the Domain objects which encapsulate business logic, data retrieval, etc. The View displays information to the user and allows them to provide input to the application. The Controller handles the interactions between the View and the Model.
</p>




<p>
  This separation is a very good design principle that generally helps prevent <a href="https://en.wikipedia.org/wiki/Spaghetti_code" target="_blank">spaghetti code</a>. Sometimes though the separation might break down.
</p>




<p>
  Rails provides the Active Record Callbacks which allows you to write code that will respond to the lifecycle events of the Model objects. For example you could log information every time a specific kind of Model object is saved. For example you could record some information every time an Account changed using the following:
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  You might have noticed a limitation with the previous API though. You didn't notice? The only information passed to the model is the Object that is being changed. What if you want more context than this? For example, what if you want to audit not only the values that changed them, but the user who made the change?
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(current_user, self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  How do you get the <code>current_user</code> value? Well, you have to plan ahead a little bit. The User in this application is stored in the HTTP Session when the user is authenticated. The session isn't directly available to the Model level so you have to figure out a way around this. One way to accomplish this is by using a named <a href="http://ruby-doc.org/core-2.3.0/Thread.html#M000484" target="_blank">Thread local variable</a>. Each HTTP request is served by its own thread. That means that a variable stored as thread local will be available for the entire processing of a request.
</p>




<p>
  The UserInfo module encapsulates reading and writing the User object from/to the Thread local. This module can then be mixed in with other objects for easy access.
</p>


<p>{% codeblock user_info.rb lang:ruby %}
module UserInfo
  def current_user</p>

<pre><code>Thread.current[:user]
</code></pre>

<p>  end</p>

<p>  def self.current_user=(user)</p>

<pre><code>Thread.current[:user] = user
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  A <code>before_filter</code> set in the ApplicationController will be called before any action is called in any controller. You can take advantage of this to copy a value out of the HTTP session and set it in the Thread local:
</p>


<p>{% codeblock user_info.rb lang:ruby %}
class ApplicationController &lt; ActionController::Base
  before_filter :set_user</p>

<p>  protected
  def authenticate</p>

<pre><code>unless session[:user]
  redirect_to :controller =&gt; "login"
  return false
end
</code></pre>

<p>  end</p>

<p>  # Sets the current user into a named Thread location so that it can be accessed by models and observers
  def set_user</p>

<pre><code>UserInfo.current_user = session[:user]
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  At any point in a Model class that you need to have access to those values you can just mixin the helper module and then use its methods to access the data. In this final example we mixin the UserInfo module to our model and it will now have access to the <code>current_user</code> method:
</p>


<p>{% codeblock account.rb lang:ruby %}
class Account &lt; ActiveRecord::Base
  include UserInfo</p>

<p>  after_update :log_audit_change</p>

<p>  private
  def log_audit_change</p>

<pre><code>Audit.audit_change(current_user, self.id, self.new_balance)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  You generally shouldn't need this kind of trick outside of a model. In most cases the Controller should pass all of the information needed by a Model object to it through its methods. That will allow the Model objects to interact and the Controller to do the orchestration needed. But in a few special cases, this trick might be handy.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails Tagging]]></title>
    <link href="http://geekhmer.github.io/blog/2016/01/26/rails-tagging/"/>
    <updated>2016-01-26T15:03:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/01/26/rails-tagging</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Rails Tagging" />
</p>




<p>
  For instance, in a social network, a user might have tags that are called skills, interests, sports, and more. This article will show you how to implement tagging in your Rails application. Let’s run through this with me.
</p>




<p>
  <strong>Installation</strong><br/>
  Add gem <code>acts-as-taggable-on</code> to your Gemfile:
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &lsquo;acts-as-taggable-on&rsquo;
{% endcodeblock %}</p>

<p>
  and run bundle:
</p>


<p>{% codeblock lang:ruby %}
bundle
{% endcodeblock %}</p>

<p>
  install migrations:
</p>


<p>{% codeblock lang:ruby %}
rails generate acts_as_taggable_on:migration
rake db:migrate
{% endcodeblock %}</p>

<p>
  This creates some tables and doesn't need to know anything specific about your models. The models and concerns for working with these tables (Tag, Tagging, etc).
</p>




<p>
  <strong>Model Integration</strong>
</p>


<p>{% codeblock app/models/post.rb lang:ruby %}
class Post
  acts_as_taggable
end
{% endcodeblock %}</p>

<p>
  Now you can do, eg:
</p>


<p>{% codeblock lang:ruby %}
post = Post.create
post.tag_list = &ldquo;programming, ruby, rails&rdquo;
post.tag_list</p>

<h1>=> [&lsquo;programming&rsquo;, &lsquo;ruby&rsquo;, &lsquo;rails&rsquo;]</h1>

<p>{% endcodeblock %}</p>

<p>
  <code>#tag_list=</code> takes a string and splits it up, using the resulting substrings to find_or_create Tags, and associate them with the taggable thing (eg, <code>Post</code>), through <code>Taggings</code>. You don't need to know this.
</p>




<p>
  The important thing is that, with <code>#tag_list=</code> we can manage tags via a comma-separated-list in a text field in a form.
</p>




<p>
  <strong>Controller Integration</strong>
</p>


<p>{% codeblock app/controllers/posts_controller.rb lang:ruby %}
class PostsController &lt; ApplicationController
  def create</p>

<pre><code>@post = Post.create(post_params)
redirect_to @post
</code></pre>

<p>  end</p>

<p>  def post_params</p>

<pre><code>params.require(:post).permit(:title, :body, :tag_list)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  This is assuming you're trying to tag an existing <code>Post</code> model with <code>title</code> and <code>body</code> fields, web-accessible through an existing <code>PostsController</code>, with <code>index</code>, <code>show</code>, <code>new</code>, etc. methods.
</p>




<p>
  Substitute your own, the important machinery here is whitelisting <code>tag_list</code> from the <code>params</code>.
</p>




<p>
  <strong>Form Integration</strong>
</p>


<p>{% codeblock app/views/posts/_form.html.erb lang:ruby %}
&lt;%= form_for post do |f| %>
  &lt;%= f.text_field :title %>
  &lt;%= f.text_area :body %>
  &lt;%= f.text_field :tag_list %>
  &lt;%= f.submit %>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  Now you can create tags for stuff. How about displaying them? Couple options, I'll go through the most explicit (a <code>TagsController</code> with index and show actions), but they can be rolled up into other controllers/actions.
</p>




<p>
  <strong>Controller</strong>
</p>


<p>{% codeblock config/routes.rb lang:ruby %}
Rails.application.routes.draw do
  resources :posts
  resources :tags, only: [:index, :show]
end
{% endcodeblock %}</p>

<p>{% codeblock app/controllers/tags_controller.rb lang:ruby %}
class TagsController &lt; ApplicationController
  def index</p>

<pre><code>@tags = ActsAsTaggableOn::Tag.all
</code></pre>

<p>  end</p>

<p>  def show</p>

<pre><code>@tag =  ActsAsTaggableOn::Tag.find(params[:id])
@posts = Post.tagged_with(@tag.name)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  It's unfortunate we have to do this slightly awkward workaround with <code>Post.tagged_with(@tag.name)</code> in <code>tags#show</code>. The <code>ActsAsTaggableOn::Tag</code> model does not have a built-in relationship with its taggable types (this is a necessary consequence of some polymorphism which we're not using here). We could add one for <code>Post</code>, but this way is easier to demonstrate.
</p>




<p>
  <strong>Tags Views</strong>
</p>


<p>{% codeblock app/views/acts_as_taggable_on/tags/_tag.html.erb lang:ruby %}
&lt;%= link_to tag.name, tag_path(tag) %>
{% endcodeblock %}</p>

<p>{% codeblock app/views/tags/index.html.erb lang:ruby %}</p>

<h1>Tags</h1>


<p>&lt;%= render @tags %>
{% endcodeblock %}</p>

<p>{% codeblock app/views/tags/show.html.erb lang:ruby %}</p>

<h1><%= @tag.name %></h1>


<div><%= render @posts %></div>


<p>{% endcodeblock %}</p>

<p>
  Note the partial path is <code>acts_as_taggable_on/tags/tag</code>. This is so we can just say <code>render @tags</code> and let rails do its implicit magic. There are other ways to organize everything, but this is the simplest.
</p>




<p>
  <strong>View Integration</strong>
</p>


<p>{% codeblock app/views/posts/_post.html.erb lang:ruby %}</p>

<h2><%= link_to post.title, post_path(post) %></h2>


<div><%= render post.tags %></div>


<p>{% endcodeblock %}</p>

<p>{% codeblock app/views/posts/index.html.erb lang:ruby %}</p>

<h1>Posts</h1>


<p>&lt;%= render @posts %>
{% endcodeblock %}</p>

<p>{% codeblock app/views/posts/show.html.erb lang:ruby %}</p>

<h1><%= @post.title %></h1>


<div><%= @post.body %></div>


<div><%= render @post.tags %></div>


<p>{% endcodeblock %}</p>

<p>
  And that should be it. It'll look shitty, but I hope you can figure out how to elaborate on this once you have it working. If anything here is assuming familiarity with something you don't have, ask and I will gladly elaborate.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 5 ActionCable Architecture and Concepts]]></title>
    <link href="http://geekhmer.github.io/blog/2016/01/23/rails-5-actioncable-architecture-and-concepts/"/>
    <updated>2016-01-23T00:23:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/01/23/rails-5-actioncable-architecture-and-concepts</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rail_5_beta_1.jpg" width="600" alt="Rails 5 ActionCable Architecture and Concepts" />
</p>




<p>
  ActionCable is an component of Ruby on Rails 5.0 - it is the first "official" solution for integrating websocket communication with Rails. 
</p>




<p>
  <strong>Websocket Concepts</strong><br/>
  The basic protocol that is pervasive in browser server interaction is HTTP. This is the protocol that gets used when a browser asks for an HTML page, JavaScript or CSS assets.
</p>




<p>
  An HTTP connection is typically short-lived, initiated by the browser and ends when the application server has returned a response. This poses a problem given an event that browsers need to know about, but have not asked for - the server has no way to send data to the browser unasked.
</p>




<p>
  Before websockets, developers have opted for polling loops or long-running http requests (ActionController::Live) to solve such cases, both of which have their own technical difficulties.
</p>




<p>
  Websockets enable browsers and application servers to keep an open connection, enabling both parties to initiate sending data to each other. Given a websocket connection, a server will send an event message to the browser through an open websocket connection, enabling direct interaction between events on a server and the browser.
</p>




<p>
  <strong>ActionCable Architecture and Concepts</strong><br/>
  Traditionally, the websocket way of handling connections did not integrate well into a Rails application - the process of handling a request in Rails is fundamentally aligned with the request-response-end way HTTP connections are handled.
</p>




<p>
  As such, ActionCable does not hook into the typical Rails MVC handling of requests, but adds another entry point to a Rails application - the ActionCable server: This server is, as of now, started as a different process dedicated to handling multiple open websocket connections while loading all components of the Rails application and providing developers the comfort of using its components. The Rails server will propagate messages to the ActionCable server by pushing them to a queue that the ActionCable server is listening to. In the current implementation, this role is given to a Redis instance.
</p>




<p>
  We can explore the architecture and the way communication works between the components using the example of a chat application: It allows multiple users to connect to it and send messages to each other. Users receive messages from other users immediately i.e. users will not need to refresh the browser to see a new message but see it pop up at the end of the message list. You know, a chat like you would expect.
</p>




<p>
  Let's trace one possible way of propagation of a user’s message:<br/>
  - A user opens the page in his browser which in turn opens a websocket connection to the ActionCable server (Websocket).<br/>
  - A user sends the message by remote form submission to the Rails server (HTTP).<br/>
  - The Rails server persists the message and publishes a message including the user and the message body to the queue. It sends an acknowledgement to the user. This ends the HTTP request.<br/>
  - The ActionCable server receives the published message from the queue. It publishes the user and message body to all relevant open websocket connections.<br/>
  - All relevant browsers connected to the ActionCable server receive the message and show it in the DOM.
</p>




<p>
  <img src="http://geekhmer.github.io/images/rails_5_actioncable_concepts.png" width="600" alt="Rails 5 ActionCable Architecture and Concepts" />
</p>




<p>
  To allow for differentiation between different groups of users, ActionCable uses the concept of channels: A user may subscribe to a select few of all available channels and thus only receive messages meant for the given channels. If the chat application were to have multiple "rooms", a user could subscribe to each room via a designated channel.
</p>




<p>
  On the technical side, ActionCable uses EventMachine to handle connections and spawns a new Ruby thread for handling messages. This means that an ActionCable server will need to be multi-threaded.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10 Tips to Speed Up Rails on the Front]]></title>
    <link href="http://geekhmer.github.io/blog/2015/10/26/10-tips-to-speed-up-rails-on-the-front/"/>
    <updated>2015-10-26T22:12:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/10/26/10-tips-to-speed-up-rails-on-the-front</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rails_artwork.jpg" alt="10 Tips to Speed Up Rails on the Front" />
</p>




<p>
  Is your Rails website performing poorly? Are clients and users complaining about 5-10 second pageloads, timeouts on mobile devices, or images that take forever to display? In some cases the solution lies on the backend — caching requests, speeding up DB queries, etc — but often, there are front-end optimizations you can look at first, that could have a huge effect on how fast a site feels. 
</p>




<p>
  <h3>Evaluating front-end Performance</h3>
  Check out <a href="http://www.webpagetest.org/" target="_blank">www.webpagetest.org</a>. For a quick glance at your site, look at the grades in the top right for immediate problems, and also check the two "Speed Index" measurements for first and repeat views. Since webpagetest saves all your tests, you can re-run after making some changes to easily see what's improved.
</p>




<p>
  <h3>Avoiding Premature Optimization</h3>
  Performance optimization takes time and resources, both of which are often in short supply. It’s hard to find the point where optimizations start to cost more than they save, and every site and team have their own unique challenges. I’ve ordered the notes in this post in order of payoff: if you want to start optimizing but don’t know where to begin, the first few ideas on this list will probably give you the biggest bang for you buck.
</p>




<p>
  <h3>GZIP</h3>
  The biggest, easiest performance you can implement is gzipping HTML/JSON/JS/CSS/font file responses. It can drastically reduce the size of transferred files, but it’s easy to forget and isn’t in most default configs.<br/>
  - <a href="https://robots.thoughtbot.com/content-compression-with-rack-deflater" target="_blank">Using Rack:Deflater</a><br/>
  - <a href="https://richonrails.com/articles/enabling-compression-for-nginx" target="_blank">Using nginx config</a><br/>
  - <a href="http://www.phpied.com/gzip-your-font-face-files/" target="_blank">Gzipping font files</a>
</p>




<p>
  <h3>keep-alive</h3>
  <a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank">keep-alive</a> is another easy win that speeds up asset delivery by reusing the existing connection between client and server. <a href="http://www.feedthebot.com/pagespeed/keep-alive.html" target="_blank">Turning it</a> on should be a no-brainer.
</p>




<p>
  <h3>Optimize user-uploaded Images</h3>
  You generally want to convert all uploaded images to JPGs, strip metadata, and optimize them as much as you can without heavy quality loss. Without this step, an admin or user can easily tank the pagesize by uploading a 24-bit PNG or similarly uncompressed image. I recommend <a href="https://github.com/markevans/dragonfly" target="_blank">Dragonfly</a> for on-the-fly image optimization — it lets front-end developers and designers fiddle with image details without needing to go back and update all your existing images on production after the change.
</p>




<p>
  <h3>Caching and CDNs</h3>
  <strong>Cache expiration</strong><br/>
  Set all assets (JS, CSS, images, fonts) to expire in a year, using either far-future expires or max-age Cache-Control headers. There are a lot of simple instructions available for setting this on <a href="https://viget.com/extend/http:/http:/guides.rubyonrails.org/asset_pipeline.html#far-future-expires-header" target="_blank">the asset pipeline</a> and for <a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html" target="_blank">CDN assets</a>.
</p>




<p>
  <strong>Fingerprinting</strong><br/>
  If you set far-future caching, you need unique, fingerprinted filenames. The asset pipeline’s precompile command will already handle this, but in most cases it won’t happen automatically for user-uploaded assets. For example, if a user edits their avatar image locally and re-uploads it to the server with the same name, and you’re serving it with far-future expires headers, you’ll have a problem. If you’re uploading files with something like <a href="https://github.com/carrierwaveuploader/carrierwave/issues/182#issuecomment-601021" target="_blank">Carrierwave</a> or <a href="https://github.com/thoughtbot/paperclip#md5-checksum--fingerprint" target="_blank">Paperclip</a>, make sure you’re taking this step.
</p>




<p>
  <strong>CDN</strong><br/>
  Migrating user-uploaded images and Rails assets to a CDN can improve download time by moving asset servers “closer” to the user. Both caching and fingerprinting rules still apply to CDNs.
</p>




<p>
  <h3>SPDY</h3>
  SPDY is a networking protocol that can speed up page performance considerably, especially on pages with a lot of assets (<a href="http://www.httpvshttps.com/" target="_blank">example</a>). It’s available in the <a href="https://viget.com/extend/http:/http:/caniuse.com/#feat=spdy" target="_blank">majority of browsers</a> and ready for production use. It requires that you set up SSL, which is admittedly a hassle, but <a href="https://bugsnag.com/blog/spdy-on-rails" target="_blank">it isn’t much work beyond that</a>.
</p>




<p>
  <h3>Inlining assets</h3>
  (Note: If you're using SPDY, it's recommended that you DON'T inline your assets — <a href="http://dev.chromium.org/spdy/spdy-best-practices" target="_blank">see SPDY best practices</a>. <a href="http://viget.com/extend/rails-front-end-performance#comment-1775457785" target="_blank">Thanks Robert Fletcher!</a>)
</p>




<p>
  <strong>JS</strong><br/>
  As a general rule, loading JS in the head is a bad idea — <a href="https://developer.yahoo.com/blogs/ydn/high-performance-sites-rule-6-move-scripts-bottom-7200.html" target="_blank">you want to move it to the bottom of the body</a>. However, in some cases moving it isn’t possible. If a design relies on Modernizr to add classes to the body as early as possible to create a consistent visual experience, Modernizr <a href="https://github.com/Modernizr/Modernizr/issues/878#issuecomment-41448059" target="_blank">needs to remain in the head</a>. In this case, try inlining the JS in a script tag instead of creating an extra, blocking request. This technique trades a faster initial pageload for slower subsequent pageloads (since subsequent loads will no longer load the file from browser cache). In a lot of cases the other pageloads are just barely slower, and it’s a good tradeoff.
</p>




<p>
  <strong>CSS</strong><br/>
  As a site grows, it becomes unreasonable to bundle all styles into a single application.css file. Users can end up viewing pages that load 100% of a site’s styles but only use 5-10%. In cases like this, you can break up page-specific styles into individual files and load them with <a href="https://gist.github.com/averyvery/45cede57d335fe0b6b55" target="_blank">a scheme that uses the controller/action to find CSS files</a>.
</p>




<p>
  Taking it further, there’s a good chance that if your view-specific CSS is small and users aren’t visiting many instances of the same view, making them request a second stylesheet isn’t necessary — just like with JS, you can inline them onto the page. <a href="https://gist.github.com/averyvery/6e4576023b395de1aaf5" target="_blank">Check out this gist for the setup I've used to inline CSS and JS assets in the past</a>.
</p>




<p>
  <strong>Images</strong><br/>
  If you have pretty small images or single unique images on a view, it could be worthwhile to inline them as base64 strings instead of sending them as separate requests, using <a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/base64/rdoc/Base64.html#strict_encode64-method" target="_blank">Ruby’s Base64 module</a>. (Warning: in IE8, your base64-encoded images need to be 32kb or smaller, or they simply won’t display.)
</p>




<p>
  <h3>jQuery and UJS</h3>
  Rails ships with jQuery 1.9.x and jquery-ujs built into application.js, but jQuery is a pretty big library, and presents some optimization opportunities:<br/>
  - Switch to jQuery 2.x — it’s smaller, but means dropping support for IE8. You could also use browser conditionals to load 1.9 for IE8 and below and 2.x for above, but you still want to combine jQuery into a single file with your other scripts, so you might end up with something like application-oldjquery.js and application.js.<br/>
  - Cut UJS, or cut them both — if you’re not using any UJS features, you can remove it, which might make jQuery an unnecessary dependency.
</p>




<p>
  At the time of this writing there’s no jQuery-less alternative for UJS, but it sounds like <a href="http://www.reddit.com/r/rails/comments/2fzk5z/what_does_rails_use_jquery_for_it_is_possible_to/ckeduvo" target="_blank">the team has considered the idea</a>.
</p>




<p>
  <h3>Pagespeed</h3>
  <a href="https://developers.google.com/speed/pagespeed/module" target="_blank">Google’s pagespeed module</a> gives you a number of tools that can speed up front-end performance by making minor tweaks (trimming the domain out of local URLs, inserting DNS prefetch tags, collapsing whitespace) or major ones (lazy-loading images). I encourage you to <a href="https://viget.com/extend/http:/https:/developers.google.com/speed/pagespeed/module/download" target="_blank">install it</a> and investigate <a href="https://developers.google.com/speed/pagespeed/module/filters" target="_blank">some of the filters</a>. Each filter has documented "Risks" that are worth reading before you implement — some of them, like <a href="https://developers.google.com/speed/pagespeed/module/filter-quote-remove" target="_blank">remove quotes</a> are low-risk filters that you could probably implement today with no downside.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
