<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2014-08-14T09:48:18+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[What's New in Rails4 View?]]></title>
    <link href="http://geekhmer.github.io/blog/2014/08/14/whats-new-in-rails4-view/"/>
    <updated>2014-08-14T08:37:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/08/14/whats-new-in-rails4-view</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/what_is_new_in_rails4.png" width="500" />
</p>




<p>
  Well, previouse article I had talked about <a href="http://geekhmer.github.io/blog/2014/08/09/whats-new-in-rails4-activemodel/">What's New in Rails4 ActiveModel?</a>.
  Today We are looking at view:
</p>




<p>
  Assume we have an owner class which has many items and each items are usualy belongs to an owner:
</p>


<p>{% codeblock lang:ruby %}
class Owner &lt; ActiveRecord::Base
  has_many :items
end
{% endcodeblock %}</p>

<p>{% codeblock lang:ruby %}
class Item &lt; ActiveRecord::Base
  belongs_to :owner
end
{% endcodeblock %}</p>

<p>
  <strong>Select box</strong><br/>
  - Rails3 & 4<br/>
  In Rails3 & 4 if we want to build a select box with owner we could do it with a single method called:
</p>


<p>{% codeblock lang:ruby %}
collection_select(:item, :owner_id, Owner.all, :id, :name)
{% endcodeblock %}</p>

<p>
  <strong>Radio button & checkbox</strong><br/>
  - Rails3
  In Rails3 we need do with the loops and builds each of the elements:
</p>


<p>{% codeblock lang:ruby %}
&lt;% @owners.each do |owner| %>
  &lt;%= radio_button_tag :owner_id, owner.id %>
  &lt;%= owner.name %>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  HTML output: 
</p>


<p>{% codeblock lang:ruby %}
<input id="owner_id" name="owner_id" type="radio" value="1" /> Slow-draw
<input id="owner_id" name="owner_id" type="radio" value="2" /> Sheriff
{% endcodeblock %}</p>

<p>
  - Now in Rails4 we have <code>collection_radio_buttons & collection_check_boxes</code> method which builds all elements from a collection:
</p>


<p>{% codeblock lang:ruby %}
collection_radio_buttons(:item, :owner_id, Owner.all, :id, :name)
collection_check_boxes(:item, :owner_id, Owner.all, :id, :name)
{% endcodeblock %}</p>

<p>
  <strong>Date field</strong><br/>
  - Rails3<br/>
  At some points we must use <code>date_select</code> form helper:
</p>


<p>{% codeblock lang:ruby %}
&lt;%= f.date_select :return_date %>
{% endcodeblock %}</p>

<p>
  HTML output:
</p>


<p>{% codeblock lang:ruby %}
<select id="item_return_date_1i" name="item[return_date(1i)]">
  <option value="2008">2008</option>
  &hellip;
</select>
<select id="item_return_date_2li" name ="item[return_date(2i)]">
  <option selected="selected" value="1">January</option>
  &hellip;
</select>
<select id="item_return_date_3i" name="item[return_date(3i)]">
  &hellip;
</select>
{% endcodeblock %}</p>

<p>
  - Rails4<br/>
  Rails4 now there is a date_field:
</p>


<p>{% codeblock lang:ruby %}
&lt;%= f.date_field :return_date %>
{% endcodeblock %}</p>

<p>
  HTML output:
</p>


<p>{% codeblock lang:ruby %}
<input id="item_return_date" name="item[return_date]" type="date">
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Use Memoization to Speed Up Your Code in Ruby/Rails]]></title>
    <link href="http://geekhmer.github.io/blog/2014/08/11/use-memoization-to-speed-up-your-code-in-ruby-slash-rails/"/>
    <updated>2014-08-11T00:28:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/08/11/use-memoization-to-speed-up-your-code-in-ruby-slash-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" />
</p>




<p>
  Have you ever heard Memoization? In this article you will get an introduction of Memoization. You will learn what it is, how you can use it to speed up your code.
</p>




<p>
  <strong>What is Memoization?</strong><br/>
  Memoization is the process of storing a computed value to avoid duplicated work by future calls.
</p>




<p>
  <strong>What are Memoization used for?</strong><br/>
  - Perform some work<br/>
  - Store the work result<br/>
  - Use stored results in future calls
</p>




<p>
  <strong>Using</strong><br/>
  In Ruby the most common pattern for using Memoization is the conditional assignment operator: <code>||=</code>.
</p>




<p>
  <strong>Example</strong><br/>
  In Rails if you've ever worked with a user login system, you really family with the pattern of loading the <code>current_user</code> in the <code>application_controller.rb</code>:
</p>


<p>{% codeblock application_controller.rb lang:ruby %}
def current_user
  User.find(session[:user_id]) if session[:user_id]
end
{% endcodeblock %}</p>

<p>
  Within each request in a Rails application you will usually see multiple calls to <code>current_user</code> that means <code>User.find</code> method is run multiple times.<br/>
</p>




<p>
  In this case, we know the problem is because there are multiple calls to <code>current_user</code> occurring. Let's fix this code by introducing Memoization into the <code>current_user</code> method and storing the result of <code>User.find</code> method by using conditional assignment to an instance variable:
</p>


<p>{% codeblock application_controller.rb lang:ruby %}
def current_user
  @current_user ||= User.find(session[:user_id]) if session[:user_id]
end
{% endcodeblock %}</p>

<p>
  Well, there are no more calls to rebuild the <code>User</code> object each time <code>current_user</code> method is called.
</p>




<p>
  <strong>When should you memoize?</strong><br/>
  - When you've got duplicated database<br/>
  - When you've got expensive calculations<br/>
  - When you've got repeated calculations that don't change<br/>
</p>




<p>
  <strong>When shouldn't you memoize</strong><br/>
  - Memoization shouldn't be used with methods that take parameters:
</p>


<p>{% codeblock lang:ruby %}</p>

<h1>incorrect</h1>

<p>def full_name
  @full_name ||= &ldquo;#{first_name} #{last_name}&rdquo;
end</p>

<p>puts full_name(&lsquo;Bunlong&rsquo;, &lsquo;Van&rsquo;) #=> &ldquo;Bunlong Van&rdquo;</p>

<p>puts full_name(&lsquo;Ryan&rsquo;, &lsquo;Van&rsquo;) #=> &ldquo;Bunlong Van&rdquo;
{% endcodeblock %}</p>

<p>
  - Memoization shouldn't be used with methods that use instance variables:
</p>


<p>{% codeblock lang:ruby %}</p>

<h1>incorrect</h1>

<p>def full_name
  @full_name ||= &ldquo;#{first_name} #{last_name}&rdquo;
end</p>

<p>@first_name = &lsquo;Bunlong&rsquo;
@last_name = &lsquo;Van&rsquo;</p>

<p>puts full_name #=> &ldquo;Bunlong Van&rdquo;</p>

<p>@first_name = &lsquo;Ryan&rsquo;
@last_name = &lsquo;Van&rsquo;</p>

<p>puts full_name #=> &ldquo;Bunlong Van&rdquo;
{% endcodeblock %}</p>

<p>
  <strong>Memoization conditional assignment have problem when return nil or false in Ruby</strong><br/>
  If you are not clear in using conditional assignment it can bite you, let try code below:
</p>


<p>{% codeblock lang:ruby %}
def print
  @print || = begin</p>

<pre><code>            puts "printing"
            sleep 2
            false
          end
</code></pre>

<p>end</p>

<p>print #=> &ldquo;printing&rdquo;</p>

<p>print #=> &ldquo;printing&rdquo;
{% endcodeblock %}</p>

<p>
  Suprised that "printing" was printed twice? Conditional assignment is always going to run if the instance variable <code>@print</code> is false or nil.<br/>
</p>




<p>
  Well, we can solve the problem by using <code>defined?</code>:
</p>


<p>{% codeblock lang:ruby %}
def print
  return @print if defined?(@print)
  puts &ldquo;printing&rdquo;
  sleep 2
  @print = false
end</p>

<p>print #=> &ldquo;printing&rdquo;</p>

<p>print
{% endcodeblock %}</p>

<p>
  <strong>Memoization conditional assignment have problem when return nil or false in Rails</strong><br/>
</p>


<p>{% codeblock lang:ruby %}
def current_user
  @current_user ||= User.find(session[:user_id]) if session[:user_id]
end
{% endcodeblock %}</p>

<p>
  What's happen if <code>User.find</code> return nil? Conditional assignment is always going to run and current_user method is always going to call if the instance variable <code>@print</code> is false or nil.
</p>




<p>
  Well, we can fix the problem by using the Memoizable API in Rails:
</p>


<p>{% codeblock lang:ruby %}</p>

<h1>somewhere inside the class</h1>

<p>extend ActiveSupport::Memoizable</p>

<p>def current_user
  @current_user ||= User.find(session[:user_id]) if session[:user_id]
end
memoize :current_user
{% endcodeblock %}</p>

<p><p>
  Or we can use <a href="https://github.com/dkubb/memoizable" target="_blank">Memoizable</a> to fix this problem
<p></p>

<p><p>
  So far so good, I hope this article comes in handy for some of you who haven’t heard of memoization yet or who just didn’t really understand what’s going on there. :)
</p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's New in Rails4 ActiveModel?]]></title>
    <link href="http://geekhmer.github.io/blog/2014/08/09/whats-new-in-rails4-activemodel/"/>
    <updated>2014-08-09T00:16:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/08/09/whats-new-in-rails4-activemodel</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/what_is_new_in_rails4.png" width="500" />
</p>




<p>
  Well, previouse article I had talked about <a href="http://geekhmer.github.io/blog/2014/08/05/good-rails3-activerecord-finder-vs-very-good-rails4-activerecord-finder/">What's New in Rails4 ActiveRecord Finder?</a>.
  Today please keep going to take a look "What's New in Rails4 ActiveModel?":
</p>




<p>
  <strong>SCOPES</strong><br/>
</p>


<p>
  <strong>eager-evaluated scopes are deprecated</strong><br/>
  - Rails3:
</p>


<p>{% codeblock Rails3 lang:ruby %}
scope :sold, where(state: &lsquo;sold&rsquo;)
default_scope where(state: &lsquo;available&rsquo;)
{% endcodeblock %}</p>

<p>
  Warning:<br/>
  - Useing #scope without passing a callable object is deprecated.<br/>
  - Calling #default_scope without a block is deprecated.
</p>




<p>
  - Rails4:<br/>
   Scopes should take a proc object:
</p>


<p>{% codeblock Rails4 lang:ruby %}
scope :sold, &ndash;>{ where(state: &lsquo;sold&rsquo;) }
{% endcodeblock %}</p>

<p>
  Defaults scopes should take proc object or a block:
</p>


<p>{% codeblock Rails4 lang:ruby %}
default_scope { where(state: &lsquo;available&rsquo;) }
default_schop &ndash;>{ where(state: &lsquo;available&rsquo;) }
{% endcodeblock %}</p>

<p>
  <strong>RELATION#NONE</strong><br/>
</p>




<p>
  - Rails3:
</p>


<p>{% codeblock Rails3 lang:ruby %}
class User &lt; ActiveRecord::Base
  def visible_posts</p>

<pre><code>case role
when 'Country Manager'
  Post.where(country: country)
when 'Reviewer'
  Post.published
when 'Bad User'
  [] #represents empty collection
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock lang:ruby %}
  @posts = current_user.visible_posts
  @posts.recent
{% endcodeblock %}</p>

<p>
  @posts.recent error when 'Bad User' because NoMethodError: undefined method 'recent' for []:Array.<br/>
  One way we can fix this:
</p>


<p>{% codeblock lang:ruby %}
@posts = current_user.visible_posts
if @posts.any? # must check for presence
  @posts.recent
else
  [] # must return empty collection to caller
end
{% endcodeblock %}</p>

<p>
  Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
class User &lt; ActiveRecord::Base
  def visible_posts</p>

<pre><code>case role
when 'Country Manager'
  Post.where(country: country)
when 'Reviewer'
  Post.published
when 'Bad User'
  Post.none # returns ActiveRecord:Relation and never hits the database
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock lang:ruby %}
@posts = current_user.visible_posts
@posts.recent # no need to check for presence
{% endcodeblock %}</p>

<p>
Post.none returns ActiveRecord:Relation and never hits the database and @posts.recent no need to check for presence.
</p>




<p>
  <strong>RELATION#NOT</strong>
</p>




<p>
  Rails3: 
</p>


<p>{% codeblock Rails3 lang:ruby %}
Post.where(&lsquo;author != ?&rsquo;, author)
{% endcodeblock %}</p>

<p>
  When author is nil it's going to generate incorrect SQL syntax: <code>SELECT "posts".* FROM "posts" WHERE (author != NULL)</code><br/>
  One way we can fix this:
</p>


<p>{% codeblock Rails3 lang:ruby %}
if author
  Post.where(&lsquo;author != ?&rsquo;, author)
else
  Post.where(&lsquo;author IS NOT NULL&rsquo;)
end
{% endcodeblock %}</p>

<p>
  Rails4: 
</p>


<p>{% codeblock Rails4 lang:ruby %}
Post.where.not(author: author)
{% endcodeblock %}</p>

<p>
  When author is nill it's goint to generate correct SQL syntax: <code>SELECT "posts".* FROM "posts" WHERE (author IS NOT NULL)</code>
</p>




<p>
  <strong>RELATION#ORDER</strong>
</p>




<p>
  <strong>case1</strong>
</p>




<p>
  Rails3:
</p>


<p>{% codeblock Rails3 lang:ruby %}
class User &lt; ActiveRecord:Base
  default_scope { order(:name) }
end</p>

<p>User.order(&ldquo;created_at DESC&rdquo;)
{% endcodeblock %}</p>

<p>
  It's going to generate SQL: <code>SELECT * FROM users ORDER BY name asc, created_at desc</code>, new calls to order are appended.
</p>




<p>
  Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
class User &lt; ActiveRecord:Base
  default_scope &ndash;>{ order(:name) }
end</p>

<p>User.order(created_at: :desc)
{% endcodeblock %}</p>

<p>
  It's going to generate SQL: <code>SELECT * FROM users ORDER BY created_at desc</code>, name asc New calls to order are prepend.
</p>




<p>
  <strong>case2</strong>
</p>




<p>
  Rails3:
</p>


<p>{% codeblock Rails3 lang:ruby %}
User.order(:name, &lsquo;created_at DESC&rsquo;)
{% endcodeblock %}</p>

<p>
  Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
User.order(:name, created_at: :desc)
{% endcodeblock %}</p>

<p>
It's going to generate SQL: <code>SELECT * FROM users ORDER BY name asc, created_at desc</code>
</p>




<p>
  Rails3:
</p>


<p>{% codeblock Rails3 lang:ruby %}
User.order(&lsquo;created_at DESC&rsquo;)
{% endcodeblock %}</p>

<p>
  Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
User.order(created_at: :desc)
{% endcodeblock %}</p>

<p>
It's going to generate SQL: <code>SELECT * FROM users ORDER BY created_at desc</code>
</p>




<p>
  So far so good, ActiveModel in Rails4 is better. :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Test Models With RSpec in Ruby on Rails]]></title>
    <link href="http://geekhmer.github.io/blog/2014/08/07/test-models-with-rspec-in-ruby-on-rails/"/>
    <updated>2014-08-07T09:40:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/08/07/test-models-with-rspec-in-ruby-on-rails</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/ruby_on_rails.png" width="400" />
</p>




<p>
  Testing is a good pratice. You should be doing it. It will make you a better programmer and save you a great deal of headache as your web app grows up. It is especially important when working alongside other programmers. Testing is not perfect though so don't try to be perfect. Just get started, and you will improve as time goes on.
</p>




<p>
  <strong>How should I be testing?</strong><br/>
  - Using RSpec & factorygirl.<br/>
  - Testing the Model.
</p>




<p>
  <strong>Installation</strong><br/>
  Add rspec-rails and factorygirl to both the :development and :test groups in the Gemfile:
</p>


<p>{% codeblock Gemfile lang:ruby %}
group :development, :test do
  gem &lsquo;factory_girl_rails&rsquo;, &lsquo;4.2.1&rsquo;
  gem &lsquo;rspec-rails&rsquo;, &lsquo;~> 3.0.0&rsquo;
end
{% endcodeblock %}</p>

<p>
  Download and install by running command:<br>
</p>


<p>{% codeblock lang:ruby %}
bundle install
{% endcodeblock %}</p>

<p>
  Initialize the spec/ directory (where specs will reside) with:
</p>


<p>{% codeblock lang:ruby %}
rails generate rspec:install
{% endcodeblock %}</p>

<p>
  This adds the following files which are used for configuration:<br/>
  - .rspec<br/>
  - spec/spec_helper.rb<br/>
  - spec/rails_helper.rb
</p>




<p>
  <strong>Generators</strong><br/>
  Once installed, RSpec and factorygirl will generate spec files instead of Test::Unit test files when run commands like: <code>rails generate model</code> and <code>rails generate controller</code> are used.
</p>




<p>
  Example:
</p>


<p>{% codeblock lang:ruby %}
rails generate model Post
{% endcodeblock %}</p>

<p>
  After you run the command above this adds the following directory and file:<br/>
  - spec/models/posts.rb<br/>
  - spec/factories/posts.rb
</p>




<p>
  <strong>Let's get started the Model testing</strong>
</p>




<p>
  Assume we have three Models such as post.rb, category.rb, categorization.rb:
</p>


<p>{% codeblock post.rb lang:ruby %}
class Post &lt; ActiveRecord::Base
  validates :title, length: { minimum: 10, maximum: 100 }, presence: true, uniqueness: true
  validates :body, length: { minimum: 20, maximum: 200 }
  validates :status, length: { minimum: 2, maximum: 20 }, presence: true
  validates :category_id, presence: true</p>

<p>  has_many :categorizations
  has_many :categories, through: :categorizations</p>

<p>  scope :search_by_title, &ndash;> (title) { where(&ldquo;(title like ?) OR title in (?)&rdquo;, &ldquo;%#{title}%&rdquo;, title.split) }
end
{% endcodeblock %}</p>

<p>{% codeblock category.rb lang:ruby %}
class Category &lt; ActiveRecord::Base
  validates :name, length: { minimum: 10, maximum: 50 }, presence: true, uniqueness: true
  validates :short_name, length: { minimum: 10, maximum: 50 }, presence: true, uniqueness: true
  validates :description, length: { maximum: 200 }</p>

<p>  has_many :categorizations
  has_many :posts, through: :categorizations
end
{% endcodeblock %}</p>

<p>{% codeblock categorization.rb lang:ruby %}
class Categorization &lt; ActiveRecord::Base
  validates :category_id, presence: true
  validates :post_id, presence: true</p>

<p>  belongs_to :category
  belongs_to :post
end
{% endcodeblock %}</p>

<p>
  Next, we define default factorygirl object for each Models in spec/factories/:
</p>


<p>{% codeblock posts.rb lang:ruby %}
FactoryGirl.define do
  factory :post do</p>

<pre><code>title 'Ruby on Rails'
body 'Ruby on Rails is good'
status 'open'
category_id 1
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock categories.rb lang:ruby %}
FactoryGirl.define do
  factory :category do</p>

<pre><code>id 1
name 'programming'
short_name 'programming'
description 'computer programming'
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock categorizations.rb lang:ruby %}
FactoryGirl.define do
  factory :categorization do</p>

<pre><code>category_id '1'
post_id '1'
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Here, how we test each Models in spec/models/:
</p>


<p>{% codeblock post.rb lang:ruby %}
require &lsquo;spec_helper&rsquo;</p>

<p>describe Post, &lsquo;validation&rsquo; do
  it { should ensure_length_of(:title).is_at_least(10) }
  it { should ensure_length_of(:title).is_at_most(100) }
  it { should validate_presence_of(:title) }
  it { should validate_uniqueness_of(:title) }</p>

<p>  it { should ensure_length_of(:body).is_at_least(20) }
  it { should ensure_length_of(:body).is_at_most(200) }</p>

<p>  it { should ensure_length_of(:status).is_at_least(2) }
  it { should ensure_length_of(:status).is_at_most(20) }
  it { should validate_presence_of(:status) }</p>

<p>  it { should validate_presence_of(:category_id) }
end</p>

<p>describe Post, &lsquo;association&rsquo; do
  it { should have_many(:categorizations) }
  it { should have_many(:categories).through(:categorizations) }
end</p>

<p>describe Post, &lsquo;column_specification&rsquo; do
  it { should have_db_column(:title).of_type(:string).with_options(length: { minimum: 10, maximum: 100 }, presence: true, uniqueness: true) }
  it { should have_db_column(:body).of_type(:text).with_options(length: { minimum: 20, maximum: 200 }) }
  it { should have_db_column(:status).of_type(:string).with_options(length: { minimum: 2, maximum: 20, presence: true }) }
  it { should have_db_column(:category_id).of_type(:integer) }</p>

<p>  it { should have_db_index(:title).unique(true) }
end</p>

<p>describe Post, &lsquo;.search_by_name&rsquo; do
  before(:each) do</p>

<pre><code>FactoryGirl.create(:post, title: 'Ruby on Rails')
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns post that match with title&rsquo; do</p>

<pre><code>Post.search_by_title('Ruby on Rails').count.should eql 1
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns post that like title&rsquo; do</p>

<pre><code>Post.search_by_title('ruby on rails').count.should eql 1
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns post when title is blank&rsquo; do</p>

<pre><code>Post.search_by_title('').count.should eql 1
</code></pre>

<p>  end</p>

<p>  it &lsquo;returns empty when title is not match&rsquo; do</p>

<pre><code>Post.search_by_title('not match').count.should eql 0
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>{% codeblock category.rb lang:ruby %}
require &lsquo;spec_helper&rsquo;</p>

<p>describe Category, &lsquo;validation&rsquo; do
  it { should ensure_length_of(:name).is_at_least(10) }
  it { should ensure_length_of(:name).is_at_most(50) }
  it { should validate_presence_of(:name) }
  it { should validate_uniqueness_of(:name) }</p>

<p>  it { should ensure_length_of(:short_name).is_at_least(10) }
  it { should ensure_length_of(:short_name).is_at_most(50) }
  it { should validate_presence_of(:short_name) }
  it { should validate_uniqueness_of(:short_name) }
end</p>

<p>describe Category, &lsquo;association&rsquo; do
  it { should have_many(:categorizations) }
  it { should have_many(:posts).through(:categorizations) }
end</p>

<p>describe Category, &lsquo;column_specification&rsquo; do
  it { should have_db_column(:name).of_type(:string).with_options(length: { minimum: 10, maximum: 50 }, presence: true, uniqueness: true) }
  it { should have_db_column(:short_name).of_type(:string).with_options(length: { minimum: 10, maximum: 50 }, presence: true, uniqueness: true) }
  it { should have_db_column(:description).of_type(:text).with_options(length: { maximum: 200 }) }
end
{% endcodeblock %}</p>

<p>{% codeblock categorization.rb lang:ruby %}
require &lsquo;spec_helper&rsquo;</p>

<p>describe Categorization, &lsquo;validation&rsquo; do
  it { should validate_presence_of(:category_id) }
  it { should validate_presence_of(:post_id) }
end</p>

<p>describe Categorization, &lsquo;association&rsquo; do
  it { should belong_to(:category) }
  it { should belong_to(:post) }
end</p>

<p>describe Categorization, &lsquo;column_specification&rsquo; do
  it { should have_db_column(:category_id).of_type(:integer).with_options(presence: true) }
  it { should have_db_column(:post_id).of_type(:integer).with_options(presence: true) }
end
{% endcodeblock %}</p>

<p>
  To run Models specs use the following command:
</p>


<p>{% codeblock lang:ruby %}
rspec spec/models
{% endcodeblock %}</p>

<p>
  You should get back the response something like:
</p>




<p>
  <img src="http://geekhmer.github.io/images/model_testing.png" width="600"/>
</p>




<p>
  For more detail about <a href="https://github.com/rspec/rspec-rails" target="_blank">RSpec</a>, <a href="https://github.com/thoughtbot/factory_girl" target="_blank">FactoryGirl</a>.<br/>
  So far so good, We've already created 40 models specs to test model. :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Good Rails3 ActiveRecord Finder Vs Very Good Rails4 ActiveRecord Finder]]></title>
    <link href="http://geekhmer.github.io/blog/2014/08/05/good-rails3-activerecord-finder-vs-very-good-rails4-activerecord-finder/"/>
    <updated>2014-08-05T23:39:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2014/08/05/good-rails3-activerecord-finder-vs-very-good-rails4-activerecord-finder</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/what_is_new_in_rails4.png" width="500" />
</p>




<p>
  Well, previouse article I had talked about <a href="http://geekhmer.github.io/blog/2014/08/02/keyword-arguments-feature-in-ruby-2-dot-0/">Keyword Arguments Feature in Ruby 2.0</a>. now we can apply keyword arguments in Rails4.
</p>




<p>
  <strong>FINDERS</strong>
</p>




<p>  
  <strong>old-style finders are deprecated</strong><br/>
  - Rails3: 
</p>


<p>{% codeblock Rails3 lang:ruby %}
Post.find(:all, conditions: { author: &lsquo;admin&rsquo;})
{% endcodeblock %}</p>

<p>
  Warning: Calling #find(:all) is deprecated. Please call #all directly instead. You have also used finder options. Please build s scope instead of using finder options.
</p>




<p>
  - Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
Post.where(author: &lsquo;admin&rsquo;)
{% endcodeblock %}</p>

<p>
  <strong>Dynamic finder that return collections are deprecated</strong><br/>
  - Rails3:
</p>


<p>{% codeblock Rails3 lang:ruby %}
Post.find_all_by_title(&lsquo;Rails 4&rsquo;)
Post.find_last_by_author(&lsquo;admin&rsquo;)
{% endcodeblock %}</p>

<p>
  Warning: This dynamic method is deprecated. Please use e.g Post.where(...).all instead.
</p>




<p>
  - Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
Post.where(title: &lsquo;Rails 4&rsquo;)
Post.where(author: &lsquo;admin&rsquo;).last
{% endcodeblock %}</p>

<p>
  <strong>FIND_BY</strong>
</p>




<p>
- Rails3:
</p>


<p>{% codeblock Rails3 lang:ruby %}
Post.find_by_title(&lsquo;Rails 4&rsquo;) # Dynamic find_by finders that take a single argument are not deprecated.
Post.find_by_title(&lsquo;Rails 4&rsquo;, conditions: { author: &lsquo;admin&rsquo; }) # Dynamic find_by finders with conditions are deprecated.
{% endcodeblock %}</p>

<p>
  - Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
Post.find_by(title: &lsquo;Rails 4&rsquo;)
Post.find_by(title: &lsquo;Rails 4&rsquo;, author: &lsquo;admin&rsquo;)
{% endcodeblock %}</p>

<p>
  <strong>FIND_BY WITH HASH</strong>
</p>




<p>
  <strong>allows dynamic input more easily</strong><br/>
  - Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
post_params = { title: &lsquo;Rails 4&rsquo;, author: &lsquo;admin&rsquo; }
Post.find_by(post_params)</p>

<p>Post.find_by(&ldquo;published_on &lt; ?&rdquo;, 2.weeks.ago)
{% endcodeblock %}</p>

<p>
  <strong>FIND_OR_*</strong>
</p>




<p>
  <strong>dynamic finders that create new objects are deprecated</strong><br/>
  - Rails3:
</p>


<p>{% codeblock Rails3 lang:ruby %}
Post.find_or_initialize_by_title(&lsquo;Rails 4&rsquo;)
Post.find_or_create_by_title(&lsquo;Rails 4&rsquo;)
{% endcodeblock %}</p>

<p>
  Warning: This dinamic method is deprecated. Please use e.g Post.find_or_initialize_by(name: 'foo') instead.<br/>
  Warning: This dinamic method is deprecated. Please use e.g Post.find_or_create_by(name: 'foo') instead.
</p>




<p>
  - Rails4:
</p>


<p>{% codeblock Rails4 lang:ruby %}
Post.find_or_initialize_by(title: &lsquo;Rails 4&rsquo;)
Post.find_or_create_by(title: &lsquo;Rails 4&rsquo;)
{% endcodeblock %}</p>

<p>
  So far so good, let upgrade to Rails4 then refactor ActiveRecord Finder together. :)
</p>

]]></content>
  </entry>
  
</feed>
