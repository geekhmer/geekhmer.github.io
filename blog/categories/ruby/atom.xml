<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Ruby | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-03-23T15:21:14+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dynamic Programming with Ruby]]></title>
    <link href="http://geekhmer.github.io/blog/2016/02/23/dynamic-programming-with-ruby/"/>
    <updated>2016-02-23T10:32:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/02/23/dynamic-programming-with-ruby</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/happy_ruby_on_rails.jpg" width="400" alt="Dynamic Programming with Ruby" />
</p>




<p>
  I had a task to analyse the value of a cookie set by a tool on the subdomain. The value of the cookie set looked something like this:
</p>


<p>{% codeblock lang:ruby %}
&ldquo;18337|20120404|True#Q0A|18342|21-30|20120404|18344#Q1|18349|NO PARTNER|20120404|18351#Q2|18352|EMPLOYED|20120404|18353#Q4|18432|STRUGGLING|18539|WANT|20120404|18541#Q3|18358|EMPLOYED|20120404|18359#&rdquo;
{% endcodeblock %}</p>

<p>
  My task was to try to decipher the values of set inside the cookie and how they changed depending on the progress through the application that set the values. I was told the answers to questions sat next to the ID of the question. For example, the answer to the "age" question (21-30) was related to the question 18342 and would always appear as |18342|21-30|. I started out with some tests and ended up with a method like this:
</p>


<p>{% codeblock lang:ruby %}
class Answers
  attr_accessor :age, :employment_status, :has_partner</p>

<p>  def parse(cookie_contents)</p>

<pre><code>items = cookie_contents.split("|")
items.each_index do | i |
   current = items[i]
   if (current == "18342")
     @age = items[i+1]
   elsif (current == "18352")
     @employment_status = items[i+1]
   elsif (current == "18349")
     @current_partner = items[i+1]
   end
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Of course, I wanted to avoid the growing if-else statement so found a way that I could do it dynamically and focus just on the mapping from an ID to an attribute. The resulting code looked like this:
</p>


<p>{% codeblock lang:ruby %}
class Answers
  attr_accessor :age, :employment_status, :has_partner</p>

<p>  Mappings = {</p>

<pre><code>"18342" =&gt; :age=,
"18352" =&gt; :employment_status=,
"18349" =&gt; :has_partner=
</code></pre>

<p>  }</p>

<p>  def parse(cookie_contents)</p>

<pre><code>items = cookie_contents.split("|")
items.each_index do | i |
   current = items[i]
   if (Mappings.has_key?(current))
      self.public_send(Mappings[current], items[i+1])
   end
end
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  By the end of the analysis, I discovered that multiple IDs mapped to the same properties and all I had to do was add another entry into the map defining which ID mapped to what property on the object.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Rails 5 ActionCable Architecture and Concepts]]></title>
    <link href="http://geekhmer.github.io/blog/2016/01/23/rails-5-actioncable-architecture-and-concepts/"/>
    <updated>2016-01-23T00:23:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/01/23/rails-5-actioncable-architecture-and-concepts</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rail_5_beta_1.jpg" width="600" alt="Rails 5 ActionCable Architecture and Concepts" />
</p>




<p>
  ActionCable is an component of Ruby on Rails 5.0 - it is the first "official" solution for integrating websocket communication with Rails. 
</p>




<p>
  <strong>Websocket Concepts</strong><br/>
  The basic protocol that is pervasive in browser server interaction is HTTP. This is the protocol that gets used when a browser asks for an HTML page, JavaScript or CSS assets.
</p>




<p>
  An HTTP connection is typically short-lived, initiated by the browser and ends when the application server has returned a response. This poses a problem given an event that browsers need to know about, but have not asked for - the server has no way to send data to the browser unasked.
</p>




<p>
  Before websockets, developers have opted for polling loops or long-running http requests (ActionController::Live) to solve such cases, both of which have their own technical difficulties.
</p>




<p>
  Websockets enable browsers and application servers to keep an open connection, enabling both parties to initiate sending data to each other. Given a websocket connection, a server will send an event message to the browser through an open websocket connection, enabling direct interaction between events on a server and the browser.
</p>




<p>
  <strong>ActionCable Architecture and Concepts</strong><br/>
  Traditionally, the websocket way of handling connections did not integrate well into a Rails application - the process of handling a request in Rails is fundamentally aligned with the request-response-end way HTTP connections are handled.
</p>




<p>
  As such, ActionCable does not hook into the typical Rails MVC handling of requests, but adds another entry point to a Rails application - the ActionCable server: This server is, as of now, started as a different process dedicated to handling multiple open websocket connections while loading all components of the Rails application and providing developers the comfort of using its components. The Rails server will propagate messages to the ActionCable server by pushing them to a queue that the ActionCable server is listening to. In the current implementation, this role is given to a Redis instance.
</p>




<p>
  We can explore the architecture and the way communication works between the components using the example of a chat application: It allows multiple users to connect to it and send messages to each other. Users receive messages from other users immediately i.e. users will not need to refresh the browser to see a new message but see it pop up at the end of the message list. You know, a chat like you would expect.
</p>




<p>
  Let's trace one possible way of propagation of a user’s message:<br/>
  - A user opens the page in his browser which in turn opens a websocket connection to the ActionCable server (Websocket).<br/>
  - A user sends the message by remote form submission to the Rails server (HTTP).<br/>
  - The Rails server persists the message and publishes a message including the user and the message body to the queue. It sends an acknowledgement to the user. This ends the HTTP request.<br/>
  - The ActionCable server receives the published message from the queue. It publishes the user and message body to all relevant open websocket connections.<br/>
  - All relevant browsers connected to the ActionCable server receive the message and show it in the DOM.
</p>




<p>
  <img src="http://geekhmer.github.io/images/rails_5_actioncable_concepts.png" width="600" alt="Rails 5 ActionCable Architecture and Concepts" />
</p>




<p>
  To allow for differentiation between different groups of users, ActionCable uses the concept of channels: A user may subscribe to a select few of all available channels and thus only receive messages meant for the given channels. If the chat application were to have multiple "rooms", a user could subscribe to each room via a designated channel.
</p>




<p>
  On the technical side, ActionCable uses EventMachine to handle connections and spawns a new Ruby thread for handling messages. This means that an ActionCable server will need to be multi-threaded.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[10 Tips to Speed Up Rails on the Front]]></title>
    <link href="http://geekhmer.github.io/blog/2015/10/26/10-tips-to-speed-up-rails-on-the-front/"/>
    <updated>2015-10-26T22:12:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/10/26/10-tips-to-speed-up-rails-on-the-front</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rails_artwork.jpg" alt="10 Tips to Speed Up Rails on the Front" />
</p>




<p>
  Is your Rails website performing poorly? Are clients and users complaining about 5-10 second pageloads, timeouts on mobile devices, or images that take forever to display? In some cases the solution lies on the backend — caching requests, speeding up DB queries, etc — but often, there are front-end optimizations you can look at first, that could have a huge effect on how fast a site feels. 
</p>




<p>
  <h3>Evaluating front-end Performance</h3>
  Check out <a href="http://www.webpagetest.org/" target="_blank">www.webpagetest.org</a>. For a quick glance at your site, look at the grades in the top right for immediate problems, and also check the two "Speed Index" measurements for first and repeat views. Since webpagetest saves all your tests, you can re-run after making some changes to easily see what's improved.
</p>




<p>
  <h3>Avoiding Premature Optimization</h3>
  Performance optimization takes time and resources, both of which are often in short supply. It’s hard to find the point where optimizations start to cost more than they save, and every site and team have their own unique challenges. I’ve ordered the notes in this post in order of payoff: if you want to start optimizing but don’t know where to begin, the first few ideas on this list will probably give you the biggest bang for you buck.
</p>




<p>
  <h3>GZIP</h3>
  The biggest, easiest performance you can implement is gzipping HTML/JSON/JS/CSS/font file responses. It can drastically reduce the size of transferred files, but it’s easy to forget and isn’t in most default configs.<br/>
  - <a href="https://robots.thoughtbot.com/content-compression-with-rack-deflater" target="_blank">Using Rack:Deflater</a><br/>
  - <a href="https://richonrails.com/articles/enabling-compression-for-nginx" target="_blank">Using nginx config</a><br/>
  - <a href="http://www.phpied.com/gzip-your-font-face-files/" target="_blank">Gzipping font files</a>
</p>




<p>
  <h3>keep-alive</h3>
  <a href="https://en.wikipedia.org/wiki/HTTP_persistent_connection" target="_blank">keep-alive</a> is another easy win that speeds up asset delivery by reusing the existing connection between client and server. <a href="http://www.feedthebot.com/pagespeed/keep-alive.html" target="_blank">Turning it</a> on should be a no-brainer.
</p>




<p>
  <h3>Optimize user-uploaded Images</h3>
  You generally want to convert all uploaded images to JPGs, strip metadata, and optimize them as much as you can without heavy quality loss. Without this step, an admin or user can easily tank the pagesize by uploading a 24-bit PNG or similarly uncompressed image. I recommend <a href="https://github.com/markevans/dragonfly" target="_blank">Dragonfly</a> for on-the-fly image optimization — it lets front-end developers and designers fiddle with image details without needing to go back and update all your existing images on production after the change.
</p>




<p>
  <h3>Caching and CDNs</h3>
  <strong>Cache expiration</strong><br/>
  Set all assets (JS, CSS, images, fonts) to expire in a year, using either far-future expires or max-age Cache-Control headers. There are a lot of simple instructions available for setting this on <a href="https://viget.com/extend/http:/http:/guides.rubyonrails.org/asset_pipeline.html#far-future-expires-header" target="_blank">the asset pipeline</a> and for <a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Expiration.html" target="_blank">CDN assets</a>.
</p>




<p>
  <strong>Fingerprinting</strong><br/>
  If you set far-future caching, you need unique, fingerprinted filenames. The asset pipeline’s precompile command will already handle this, but in most cases it won’t happen automatically for user-uploaded assets. For example, if a user edits their avatar image locally and re-uploads it to the server with the same name, and you’re serving it with far-future expires headers, you’ll have a problem. If you’re uploading files with something like <a href="https://github.com/carrierwaveuploader/carrierwave/issues/182#issuecomment-601021" target="_blank">Carrierwave</a> or <a href="https://github.com/thoughtbot/paperclip#md5-checksum--fingerprint" target="_blank">Paperclip</a>, make sure you’re taking this step.
</p>




<p>
  <strong>CDN</strong><br/>
  Migrating user-uploaded images and Rails assets to a CDN can improve download time by moving asset servers “closer” to the user. Both caching and fingerprinting rules still apply to CDNs.
</p>




<p>
  <h3>SPDY</h3>
  SPDY is a networking protocol that can speed up page performance considerably, especially on pages with a lot of assets (<a href="http://www.httpvshttps.com/" target="_blank">example</a>). It’s available in the <a href="https://viget.com/extend/http:/http:/caniuse.com/#feat=spdy" target="_blank">majority of browsers</a> and ready for production use. It requires that you set up SSL, which is admittedly a hassle, but <a href="https://bugsnag.com/blog/spdy-on-rails" target="_blank">it isn’t much work beyond that</a>.
</p>




<p>
  <h3>Inlining assets</h3>
  (Note: If you're using SPDY, it's recommended that you DON'T inline your assets — <a href="http://dev.chromium.org/spdy/spdy-best-practices" target="_blank">see SPDY best practices</a>. <a href="http://viget.com/extend/rails-front-end-performance#comment-1775457785" target="_blank">Thanks Robert Fletcher!</a>)
</p>




<p>
  <strong>JS</strong><br/>
  As a general rule, loading JS in the head is a bad idea — <a href="https://developer.yahoo.com/blogs/ydn/high-performance-sites-rule-6-move-scripts-bottom-7200.html" target="_blank">you want to move it to the bottom of the body</a>. However, in some cases moving it isn’t possible. If a design relies on Modernizr to add classes to the body as early as possible to create a consistent visual experience, Modernizr <a href="https://github.com/Modernizr/Modernizr/issues/878#issuecomment-41448059" target="_blank">needs to remain in the head</a>. In this case, try inlining the JS in a script tag instead of creating an extra, blocking request. This technique trades a faster initial pageload for slower subsequent pageloads (since subsequent loads will no longer load the file from browser cache). In a lot of cases the other pageloads are just barely slower, and it’s a good tradeoff.
</p>




<p>
  <strong>CSS</strong><br/>
  As a site grows, it becomes unreasonable to bundle all styles into a single application.css file. Users can end up viewing pages that load 100% of a site’s styles but only use 5-10%. In cases like this, you can break up page-specific styles into individual files and load them with <a href="https://gist.github.com/averyvery/45cede57d335fe0b6b55" target="_blank">a scheme that uses the controller/action to find CSS files</a>.
</p>




<p>
  Taking it further, there’s a good chance that if your view-specific CSS is small and users aren’t visiting many instances of the same view, making them request a second stylesheet isn’t necessary — just like with JS, you can inline them onto the page. <a href="https://gist.github.com/averyvery/6e4576023b395de1aaf5" target="_blank">Check out this gist for the setup I've used to inline CSS and JS assets in the past</a>.
</p>




<p>
  <strong>Images</strong><br/>
  If you have pretty small images or single unique images on a view, it could be worthwhile to inline them as base64 strings instead of sending them as separate requests, using <a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/base64/rdoc/Base64.html#strict_encode64-method" target="_blank">Ruby’s Base64 module</a>. (Warning: in IE8, your base64-encoded images need to be 32kb or smaller, or they simply won’t display.)
</p>




<p>
  <h3>jQuery and UJS</h3>
  Rails ships with jQuery 1.9.x and jquery-ujs built into application.js, but jQuery is a pretty big library, and presents some optimization opportunities:<br/>
  - Switch to jQuery 2.x — it’s smaller, but means dropping support for IE8. You could also use browser conditionals to load 1.9 for IE8 and below and 2.x for above, but you still want to combine jQuery into a single file with your other scripts, so you might end up with something like application-oldjquery.js and application.js.<br/>
  - Cut UJS, or cut them both — if you’re not using any UJS features, you can remove it, which might make jQuery an unnecessary dependency.
</p>




<p>
  At the time of this writing there’s no jQuery-less alternative for UJS, but it sounds like <a href="http://www.reddit.com/r/rails/comments/2fzk5z/what_does_rails_use_jquery_for_it_is_possible_to/ckeduvo" target="_blank">the team has considered the idea</a>.
</p>




<p>
  <h3>Pagespeed</h3>
  <a href="https://developers.google.com/speed/pagespeed/module" target="_blank">Google’s pagespeed module</a> gives you a number of tools that can speed up front-end performance by making minor tweaks (trimming the domain out of local URLs, inserting DNS prefetch tags, collapsing whitespace) or major ones (lazy-loading images). I encourage you to <a href="https://viget.com/extend/http:/https:/developers.google.com/speed/pagespeed/module/download" target="_blank">install it</a> and investigate <a href="https://developers.google.com/speed/pagespeed/module/filters" target="_blank">some of the filters</a>. Each filter has documented "Risks" that are worth reading before you implement — some of them, like <a href="https://developers.google.com/speed/pagespeed/module/filter-quote-remove" target="_blank">remove quotes</a> are low-risk filters that you could probably implement today with no downside.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Open Sourcing a Gem]]></title>
    <link href="http://geekhmer.github.io/blog/2015/09/02/open-sourcing-a-gem/"/>
    <updated>2015-09-02T20:24:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/09/02/open-sourcing-a-gem</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/rubygems_logo.png" alt="Open Sourcing a Gem" />
</p>




<p>
  <strong>Considerations when Open Sourcing</strong><br/>
  When open sourcing a gem (or any project, this post can be generalized to not just focus on gems), there are a number of things to consider. The first check is to ensure that the use case is general enough that it is likely to be helpful to other parties. Though the project might never gain many external users, it is a good sanity check before taking on the work to open source the project. Following this there are a number of things to think out, with the purpose of determining a track of work that needs to be taken (if any) before the gem can be open sourced.
</p>




<p>
  <strong>Generalize the implementation</strong><br/>
  - Remove coupled business logic and application specific code.<br/>
  - Ensure no keys/account information were stored in the repo (even in past commits). Typically not considered a good practice, but it is something to be aware of when releasing the source of a project publicly.
</p>




<p>
  <strong>Set bounds on the responsibilities</strong><br/>
  - What is the purpose of this gem and what needs is it fulfilling?<br/>
  - Take a step back from how you currently use the library. What other potential use cases might others use it for? Is it worth generalizing the implementation to aid these other use cases?<br/>
  - Set bounds on the responsibilities that the gem will take care of.<br/>
  - What will the gem provide and what is left up to the user? In the case of Signalman, we allow users to customize the URL of the Signalman admin page, but it is up to the user to provide additional authentication besides obscurity. Signalman is a gem designed to aid with A/B testing, not authentication.<br/>
  - Try to stick to the gem's core competencies. Do not add features at a whim to quell user requests. This can cause a gem to grow out of control and become hard to manage or even discern its original purpose/intent.
</p>




<p>
  <strong>Consider strategies to manage repository ownership</strong><br/>
  - Like it or not, becoming a maintainer is a big responsibility. If you are open sourcing a project with a team, this will greatly ease the burden, but you must still consider processes to manage external pull requests and issues that arise.<br/>
  - Giving the user power and encouraging pull requests and a community that supports each other's issues can also relieve the burden of being a project maintainer. You can help this process by adding documentation for contributing and making it easy for other parties to contribute to the project. This also means providing help to newer developers; you never know who might become a leading contributor in the future.
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using reCAPTCHA in Ruby on Rails Application]]></title>
    <link href="http://geekhmer.github.io/blog/2015/07/14/using-recaptcha-in-ruby-on-rails-application/"/>
    <updated>2015-07-14T23:44:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/07/14/using-recaptcha-in-ruby-on-rails-application</id>
    <content type="html"><![CDATA[<p>
  For a site with lots of user generated content, fighting spammers can be a never ending battle. Luckily, we can use a service called reCAPTCHA to help keep spammers off our site. reCAPTCHA works by displaying an image on screen and asking the user to type what they see in the image. This works because, the spammer's spambots are unable to read the image and unable to proceed with filling out the form. reCAPTCHA is just one of a number of tools we can use to prevent spammers from abusing our websites.
</p>




<p>
  <strong>Setup Account</strong><br/>
  First, we need to create a reCAPTCHA account. Visit the <a href="http://www.google.com/recaptcha/intro/index.html" target="_blank">reCAPTCHA</a> website and click the button that says 'Get reCAPTCHA'.
</p>




<p>
  <img src="http://geekhmer.github.io/images/reCAPTCHA_1.png" width="600" alt="Using reCAPTCHA in Ruby on Rails Application" />
</p>




<p>
  On the next screen enter your label, domain, owners and check the box that says 'Get alerts about this site' then click the 'Register' button.
</p>




<p>
  <img src="http://geekhmer.github.io/images/reCAPTCHA_2.png" width="600" alt="Using reCAPTCHA in Ruby on Rails Application" />
</p>




<p>
  Make sure you copy the public key and private key and save it somewhere, you will need this information when adding reCAPTCHA to your Rails application.
</p>




<p>
  <strong>Setup Rails Application</strong><br/>
  Now we have an account, it's time to set up our Ruby on Rails application. The first thing we will need to do is include the recaptcha gem in our Gemfile. Add the following lines to your gemfile. Note that the bcrypt-ruby gem is used for our example user signup form. You don't have to include this in your application if you aren't using it for user authentication.
</p>


<p>{% codeblock Gemfile lang:ruby %}
gem &lsquo;recaptcha&rsquo;, &lsquo;~> 0.3.5&rsquo;
gem &lsquo;bcrypt-ruby&rsquo;, &lsquo;~> 3.1.2&rsquo;
{% endcodeblock %}</p>

<p>
  Next run a bundle install to install the gem:
</p>


<p>{% codeblock lang:ruby %}
bundle install
{% endcodeblock %}</p>

<p>
  Next create an initializer for recaptcha that will contain the public and private keys we mentioned earlier. Create a new initializer called recaptcha.rb and add the code listed below, make sure to modify it to contain your public and private keys.
</p>


<p>{% codeblock config/initializers.rb lang:ruby %}
Recaptcha.configure do |config|
  config.public_key  = &lsquo;Replace with your public key&rsquo;
  config.private_key = &lsquo;Replace with your private key&rsquo;
end
{% endcodeblock %}</p>

<p>
  Next create a model called User that we will use to test the reCAPTCHA functionality. Run the following commands to create the user model:
</p>


<p>{% codeblock lang:ruby %}
rails g model user name email password_digest
rake db:migrate
{% endcodeblock %}</p>

<p>
  Next, open your User model and modify it:
</p>


<p>{% codeblock app/models/user.rb lang:ruby %}
class User &lt; ActiveRecord::Base
  has_secure_password
  validates_presence_of :password, on: :create
  validates :email, uniqueness: true, presence: true
end
{% endcodeblock %}</p>

<p>
  Next create a couple controllers that will handle our user input. The first controller, Home, will provide a simple landing page that contains a sign up link. The second controller, Users, will process the actual user signup request. Run the commands below to create the controllers.
</p>


<p>{% codeblock lang:ruby %}
rails g controller Home show
rails g controller Users new create
{% endcodeblock %}</p>

<p>
  Now edit our routes file to set up a few routes for the controllers we just created. Modify the routes file so that it looks like the code listed below, being sure not to overwrite your application name on the first line:
</p>


<p>{% codeblock config/routes.rb lang:ruby %}
ReCAPTCHAExample::Application.routes.draw do
  resource :home, only: [:show], controller: :home
  resource :users, only: [:new, :create]
  root to: &ldquo;home#show&rdquo;
end
{% endcodeblock %}</p>

<p>
  Next open up your home/show view and modify it so that it looks like the code listed below:
</p>


<p>{% codeblock app/views/home/show.html.erb lang:ruby %}</p>

<h3>Welcome!</h3>


<p>
Click the link below to sign up for an account.
</p>


<p>&lt;%= link_to &ldquo;Sign Up!&rdquo;, new_users_path %>
{% endcodeblock %}</p>

<p>
  Next open up the users/new view and modify it so that it looks like the code listed below:
</p>


<p>{% codeblock app/views/users/new.html.erb lang:ruby %}</p>

<h3>New User Sign Up</h3>


<p>&lt;% if !@user.errors.empty? %>
  <ul></p>

<pre><code>&lt;% @user.errors.full_messages.each do |message| %&gt;
  &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt;
&lt;% end %&gt;
</code></pre>

<p>  </ul>
&lt;% end %>
&lt;%= form_for User.new do |f| %>
  <div></p>

<pre><code>&lt;%= f.label :name %&gt;
&lt;%= f.text_field :name %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= f.label :email %&gt;
&lt;%= f.text_field :email %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= f.label :password %&gt;
&lt;%= f.password_field :password %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= f.label :password_confirmation %&gt;
&lt;%= f.password_field :password_confirmation %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= recaptcha_tags %&gt;
</code></pre>

<p>  </div>
  <div></p>

<pre><code>&lt;%= f.submit "Sign Up" %&gt;
</code></pre>

<p>  </div>
&lt;% end %>
{% endcodeblock %}</p>

<p>
  Most of the code is self explanatory, however, you'll notice the recaptcha_tags method being called. This method is responsible for rendering the reCAPTCHA.
</p>




<p>
  Next open up our users controller and add some code to handle the request. Modify your users controller so that it looks like the code listed below.
</p>


<p>{% codeblock app/controllers/users_controller.rb lang:ruby %}
class UsersController &lt; ApplicationController
  def new</p>

<pre><code>@user = User.new
</code></pre>

<p>  end</p>

<p>  def create</p>

<pre><code>captcha_message = "The data you entered for the CAPTCHA wasn't correct.  Please try again"
@user = User.new(user_params)
if !verify_recaptcha(model: @user, message: captcha_message) || !@user.save
  render "new"
end
</code></pre>

<p>  end</p>

<p>  private
  def user_params</p>

<pre><code>params.require(:user).permit(:name, :email, :password, :password_confirmation)
</code></pre>

<p>  end
end
{% endcodeblock %}</p>

<p>
  Almost done! Now lets open up our users/create view and add the following code.
</p>


<p>{% codeblock app/views/users/create.html.erb lang:ruby %}</p>

<h3>Thank You!</h3>


<p>
Thanks for signing up!
</p>


<p>{% endcodeblock %}</p>

<p>
  Now if you start a rails server and navigate to http://localhost:3000 we will see a sign up link. if you click on the sign up link you will be presented with a sign up form, complete with a captcha to fill out. You'll notice that filling out the captcha wrongly results in a validation error message, and filling out the correct information allows the user signup to proceed.
</p>




<p>
  So far so good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
