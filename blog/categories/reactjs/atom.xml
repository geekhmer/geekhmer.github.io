<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ReactJS | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/reactjs/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2016-03-21T17:05:56+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Should I Use ReactJS?]]></title>
    <link href="http://geekhmer.github.io/blog/2016/01/09/should-i-use-reactjs/"/>
    <updated>2016-01-09T10:32:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2016/01/09/should-i-use-reactjs</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/react_flux.jpg" width="600" alt="Should I Use ReactJS?" />
</p>




<p>
  <strong>Short answer is Yes.</strong>
</p>




<p>
  <strong>Long answer is unfortunately, Yes, for most things.</strong>
</p>




<p>
  <strong>Here's why you should use ReactJS:</strong><br/>
  - Works great for teams, strongly enforcing UI and workflow patterns.<br/>
  - UI code is readable and maintainable.<br/>
  - Componentized UI is the future of web development, and you need to start doing it now.
</p>




<p>
  <strong>Here's why you should think twice before you switch:</strong><br/>
  - ReactJS will slow you down tremendously at the start. Understanding how props, state, and component communication works is not straightforward, and the docs are a maze of information. This will be countered, in theory, by a grand speed up when your whole team is on board.<br/>
  - ReactJS does not support any browser below IE8, and never will.<br/>
  - If your application / website doesn't have very much dynamic page updating, you will be implementing a lot of code for a very small benefit.<br/>
  - You will reinvent a lot of wheels. ReactJS is young, and because there's no canonical way to do events / component communication, you'll have to build large component libraries from scratch. Does your application have dropdowns, resizable windows, or lightboxes? You'll probably have to write those all from scratch.
</p>




<p>
  So far go good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactJS Flux in Practice]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/24/reactjs-flux-in-practice/"/>
    <updated>2015-11-24T09:40:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/24/reactjs-flux-in-practice</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/react_flux.jpg" width="600" alt="ReactJS Flux in Practice" />
</p>




<p>
  To build a ReactJS application with Flux I have deviced a little library called flux-react.
</p>




<p>
  <strong>Actions</strong><br/>
  Actions are what links your components (and anything else that wants to change state) with your stores. You define them just by naming them. When calling an action the arguments will be deepCloned to avoid later mutation of complex objects passed to the store.
</p>


<p>{% codeblock lang:javascript %}
var Actions = flux.createActions([
  &lsquo;addItem&rsquo;]
);
{% endcodeblock %}</p>

<p>
  <strong>Stores</strong><br/>
  Stores are where you define your application state, update it and notify components about changes.
</p>


<p>{% codeblock lang:javascript %}
var Store = flux.createStore({
  // We put the state directly on the store object
  lists: [],
  // Then we point to the actions we want to react to in this store
  actions: [</p>

<pre><code>Actions.addItem
</code></pre>

<p>  ],
  // The action maps directly to a method. So action addItem maps to the
  // method addItem()
  addItem: function (item) {</p>

<pre><code>this.lists.push(item);
this.emit('list.add');
</code></pre>

<p>  },
  // The methods that components can use to get state information
  // from the store. The context of the methods is the store itself.
  // The returned values are deepcloned, which means
  // that the state of the store is immutable
  exports: {</p>

<pre><code>getLists: function () {
  return this.lists;
}
</code></pre>

<p>  }
});
{% endcodeblock %}</p>

<p>
  Lets see how this is used in a component before going over the concept:
</p>


<p>{% codeblock lang:javascript %}
var ComponentList = React.createClass({
  getInitialState: function () {</p>

<pre><code>return {
  lists: Store.getLists()
};
</code></pre>

<p>  },
  triggerAction: function () {</p>

<pre><code>Actions.addItem("Item added");
</code></pre>

<p>  },
  onChange: function () {</p>

<pre><code>this.setState({
  lists: Store.getLists()
});
</code></pre>

<p>  },
  componentWillMount: function () {</p>

<pre><code>Store.on('lists.add', this.onChange);
</code></pre>

<p>  },
  componentWillUnmount: function () {</p>

<pre><code>Store.off('lists.add', this.onChange);
</code></pre>

<p>  },
  render: function () {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;button onClick={this.triggerAction}&gt;Click&lt;/button&gt;
    &lt;br/&gt;&lt;br/&gt;
    {JSON.stringify(this.state.lists)}
  &lt;/div&gt;
);
</code></pre>

<p>  }
});
{% endcodeblock %}</p>

<p>
  Okay. So what I noticed was that my actions always mapped directly to a method. If the action was called "addItem", the method handling that action in my store was also called "addItem". That is why actions in "flux-react" map directly to a method.
</p>




<p>
  An other concept is the "exports". You only want to expose a set of getter methods that your components can use. Three things happens with exports:<br/>
  - The exports object is the object that is returned when creating a store.<br/>
  - All methods in exports are bound to the store, letting you use "this" to point to the state in the store.<br/>
  - Exported values are automatically deep cloned.
</p>




<p>
  Now that last part needs a bit more explenation. The state, in your store should only be changed inside the store. ex. returning a list of todos to a component should not allow that component to do changes there that is reflected in the store. This is because of debugging. If lots of different components starts to change state directly in your store you will get into trouble. So instead the "flux-react" store makes sure that any value returned from exports is deep cloned, right out of the box. The same goes for complex objects passed as arguments to an action. We do not want them to be changed later outside of the store and by doing so change the state of the store.
</p>




<p>
  How about performance? Well, the thing is that values you return from a store are not big, neither are values you pass as arguments. Yes, maybe you have a phonebook of 10.000 people in your store, but your interface will never show all 10.000 of them. You may grab the 50 first of them and the rest requires searching or pagination. In that case it is only the search result, or next page, that is deep cloned. Never all the 10.000 people.
</p>




<p>
  Full codes:
</p>


<p>{% codeblock lang:javascript %}
&lt;!DOCTYPE html>
<html>
  <head></p>

<pre><code>&lt;script type="text/javascript" src="http://fb.me/react-0.12.2.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="http://fb.me/JSXTransformer-0.12.2.js"&gt;&lt;/script&gt;
&lt;script src="flux-react.js"&gt;&lt;/script&gt;
</code></pre>

<p>  </head>
<body>
  <script type="text/jsx"></p>

<pre><code>var Actions = flux.createActions([
  'addItem']
);

var Store = flux.createStore({
  lists: [],
  actions: [
    Actions.addItem
  ],
  addItem: function (item) {
    this.lists.push(item);
    this.emit('lists.add');
  },
  exports: {
    getLists: function () {
      return this.lists;
    }
  }
});

var ComponentList = React.createClass({
  getInitialState: function () {
    return {
      lists: Store.getLists()
    };
  },
  triggerAction: function () {
    Actions.addItem("Item added");
  },
  onChange: function () {
    this.setState({
      lists: Store.getLists()
    });
  },
  componentWillMount: function () {
    Store.on('lists.add', this.onChange);
  },
  componentWillUnmount: function () {
    Store.off('lists.add', this.onChange);
  },
  render: function () {
    return(
      &lt;div&gt;
        &lt;button onClick={this.triggerAction}&gt;Click&lt;/button&gt;
        &lt;br/&gt;&lt;br/&gt;
        {JSON.stringify(this.state.lists)}
      &lt;/div&gt;
    );
  }
});

ReactDOM.renderComponent(&lt;ComponentList /&gt;, document.body);
</code></pre>

<p>  </script>
</body>
</html>
{% endcodeblock %}</p>

<p>
  You can download the source code <a href="https://github.com/Bunlong/reactjs_flux_in_practice" target="_blank">here</a>.
</p>




<p>
  So far go good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What is Flux?]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/22/what-is-flux/"/>
    <updated>2015-11-22T16:27:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/22/what-is-flux</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/react_flux.jpg" width="600" alt="What is Flux?" />
</p>




<p>
  Flux is an architecture that Facebook uses internally when working with React. It is not a framework or a library. It is a new kind of architecture that complements React and the concept of Unidirectional Data Flow (Central to the Flux Pattern).
</p>




<p>
  Facebook provide a Dispatcher javascript library. The dispatcher is a kind of global pub/sub handler that broadcasts payloads to registered callbacks.
</p>




<p>
  Flux architecture will use this Dispatcher javascript library, along with NodeJSâ€™s EventEmitter module in order to set up an event system that helps manage an applications state.
</p>




<p>
  <strong>Flux have 4 layers:</strong><br/>
  - <code>Actions</code> - Helper methods that facilitate passing data to the Dispatcher.<br/>
  - <code>Dispatcher</code> - Receives actions and broadcasts payloads to registered callbacks.<br/>
  - <code>Stores</code> - Containers for application state & logic that have callbacks registered to the dispatcher.<br/>
  - <code>Controller Views</code> - React Components that grab the state from Stores and pass it down via props to child components.
</p>




<p>
  <strong>Structure and Data Flow </strong><br/>
  Data in a Flux application flows in a single direction:<br/>
</p>




<p>
  <img src="http://geekhmer.github.io/images/flux_diagram_1.png" width="600" alt="What is Flux?" />
</p>




<p>
  The dispatcher, stores and views are independent nodes with distinct inputs and outputs. The actions are simple objects containing the new data and an identifying type property.
</p>




<p>
  The views may cause a new action to be propagated through the system in response to user interactions:
</p>




<p>
  <img src="http://geekhmer.github.io/images/flux_diagram_2.png" width="600" alt="What is Flux?" />
</p>




<p>
  All data flows through the dispatcher as a central hub. Actions are provided to the dispatcher in an action creator method, and most often originate from user interactions with the views. The dispatcher then invokes the callbacks that the stores have registered with it, dispatching actions to all stores. Within their registered callbacks, stores respond to whichever actions are relevant to the state they maintain. The stores then emit a change event to alert the controller-views that a change to the data layer has occurred. Controller-views listen for these events and retrieve data from the stores in an event handler. The controller-views call their own <code>setState()</code> method, causing a re-rendering of themselves and all of their descendants in the component tree.
</p>




<p>
  <img src="http://geekhmer.github.io/images/flux_diagram_3.png" width="600" alt="What is Flux?" />
</p>




<p>
  <strong>Summary</strong><br/>
  Flux is a pattern for unidirectional data flows Actions encapsulate events Dispatcher is a central hub that holds callbacks Stores hold app state Many implementations
</p>




<p>
  So far after reading this article, I hope that if you didnâ€™t get Facebookâ€™s Flux Architecture before, that now you can say you do. 
</p>




<p>
  If you want to use the Flux architecture. but you don't know how to use it and which library you should use, please stay turned for the next article. See you!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactJS Composable Components]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/22/reactjs-composable-components/"/>
    <updated>2015-11-22T13:17:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/22/reactjs-composable-components</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/reactjs.png" width="600" alt="ReactJS Composable Components" />
</p>




<p>
  ReactJS is all about building reusable components. In fact, with React the only thing you do is build components. Since they're so encapsulated, components make code reuse, testing, and separation of concerns easy. Let see the example below:
</p>


<p>{% codeblock lang:javascript %}
&lt;!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title></title>
  <script type="text/javascript" src="http://fb.me/react-0.12.2.js"></script>
  <script type="text/javascript" src="http://fb.me/JSXTransformer-0.12.2.js"></script>
</head>
<body>
  <script type="text/jsx"></p>

<pre><code>var App = React.createClass({
  getInitialState: function() {
    return {
      red: 0
    }
  },
  update: function(e) {
    this.setState({
      red: this.refs.red.refs.inp.getDOMNode().value
    });
  },
  render: function() {
    return (
      &lt;div&gt;
        &lt;NumInput 
          ref="red"
          min={0}
          max={255}
          step={0.01}
          val={this.state.red}
          type="number"
          label="Red"
          update={this.update} /&gt;
      &lt;/div&gt;
    );
  }
});

var NumInput = React.createClass({
  propTypes: {
    min: React.PropTypes.number,
    max: React.PropTypes.number,
    step: React.PropTypes.number,
    val: React.PropTypes.number,
    label: React.PropTypes.string,
    update:React.PropTypes.func.isRequired,
    type: React.PropTypes.oneOf(['number', 'range'])
  },
  getDefaultProps: function() {
    return {
      min: 0,
      max: 0,
      step: 1,
      val: 0,
      label: '',
      type: 'range'
    }
  },
  render: function() {
    var label = this.props.label !== '' ? &lt;label&gt;{this.props.label} {this.props.val}&lt;/label&gt; : ''
    return (
        &lt;div&gt;
          &lt;input 
            ref="inp" 
            type={this.props.type} 
            min={this.props.min} 
            max={this.props.max} 
            step={this.props.step} 
            defaultValue={this.props.val} 
            onChange={this.props.update} /&gt;
            {label}
        &lt;/div&gt;
    );
  }
});

React.render(&lt;App txt="this is the txt prop" /&gt;, document.body);
</code></pre>

<p>  </script>
</body>
</html>
{% endcodeblock %}</p>

<p>
  So far go good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactJS Mixins]]></title>
    <link href="http://geekhmer.github.io/blog/2015/11/21/reactjs-mixins/"/>
    <updated>2015-11-21T18:10:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/11/21/reactjs-mixins</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/reactjs.png" width="600" alt="ReactJS Mixins" />
</p>




<p>
  Components are the best way to reuse code in React, but sometimes very different components may share some common functionality. These are sometimes called cross-cutting concerns. React provides mixins to solve this problem.
</p>




<p>
  Example:
</p>




<p>
  Let's create a simple mixin that uses lifecycle methods for using in two components.
</p>


<p>{% codeblock lang:javascript %}
&lt;!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title></title>
  <script type="text/javascript" src="http://fb.me/react-0.12.2.js"></script>
  <script type="text/javascript" src="http://fb.me/JSXTransformer-0.12.2.js"></script>
</head>
<body>
  <script type="text/jsx"></p>

<pre><code>var ReactMixin = {
  getInitialState: function() {
    return {count: 0}
  },
  componentWillMount: function() {
    console.log('will mount');
  },
  incrementCount: function() {
    this.setState({count: this.state.count+1});
  }
}

var App = React.createClass({
  render: function() {
    return(
      &lt;div&gt;
        &lt;Button txt="this is the button" /&gt;
        &lt;br/&gt;
        &lt;Label txt="this is the label" /&gt;
      &lt;/div&gt;
    );
  }
});

var Button = React.createClass({
  mixins: [ReactMixin],
  render: function() {
    return &lt;button onClick={this.incrementCount}&gt;{this.props.txt} - {this.state.count}&lt;/button&gt;
  }
});

var Label = React.createClass({
  mixins: [ReactMixin],
  componentWillMount: function() {
    setInterval(this.incrementCount, 1000);
  },
  render: function() {
    return &lt;label&gt;{this.props.txt} - {this.state.count}&lt;/label&gt;
  }
});

ReactDOM.render(&lt;App /&gt;, document.body);
</code></pre>

<p>  </script>
</body>
</html>
{% endcodeblock %}</p>

<p>
  So far go good, That's it!!! See ya!!! :)
</p>

]]></content>
  </entry>
  
</feed>
