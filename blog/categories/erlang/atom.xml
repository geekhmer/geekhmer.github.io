<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Erlang | GeeKhmer]]></title>
  <link href="http://geekhmer.github.io/blog/categories/erlang/atom.xml" rel="self"/>
  <link href="http://geekhmer.github.io/"/>
  <updated>2015-04-16T09:31:35+07:00</updated>
  <id>http://geekhmer.github.io/</id>
  <author>
    <name><![CDATA[Bunlong Van]]></name>
    <email><![CDATA[bunlong.van@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ChicagoBoss Installation]]></title>
    <link href="http://geekhmer.github.io/blog/2015/01/28/chicagoboss-installation/"/>
    <updated>2015-01-28T22:52:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/01/28/chicagoboss-installation</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/logo_chicagoboss.svg" alt="ChicagoBoss Installation" />
</p>




<p>
  <h3>Overview</h3>
</p>




<p>
  In software development, using a framework is almost a rule for fast, clean, easy readable and standardized coding. Chicago Boss (<a href="http://www.chicagoboss.org/" target="_blank">http://www.chicagoboss.org</a>)is a framework that is heavily inspired by Rails. Set up and use Chicago Boss is easy as falling off a log. Chicago Boss allows you to code with the aforementioned standards in Erlang. Plus, offers conveniences of modern web development, including WebSocket and Comet. Basic features of Chicago Boss listed below:<br/>
  - 100% asynchronous I/O<br/>
  - Support for Erlang and Elixir code<br/>
  - BossDB: Database connection layer with an advanced ORM which with built-in support for Mnesia, MongoDB, MySQL, PostgreSQL, Riak and Tokyo Tyrant<br/>
  - BossCache: Database caching layer<br/>
  - BossMQ: Cluster–wide, channel–based message queue<br/>
  - BossRouter: URL router<br/>
  - BossSession: Session storage layer<br/>
  - BossNews: Event listener, model event system<br/>
  - BossMail: Built-in email server<br/>
  - Django and Jade template support<br/>
  - Very clean controllers as result of pattern matching<br/>
  - Auto document generation for models<br/>
  - An useful admin interface<br/>
  - Automatic code reloading
</p>




<p>
  <img src="http://geekhmer.github.io/images/hand_chicagoboss.png" alt="ChicagoBoss Installation" width="200" />
</p>




<p>
  <h3>Installation</h3>
</p>




<p>
  This short guide will help you get Chicago Boss installed and working on your system. Chicago Boss generally isn’t installed to global system path. Typically, Chicago Boss will be copied to a development directory in your path.
</p>




<p>
  <strong>Requirement</strong><br/>
  Chicago Boss is written in the Erlang programming language, so naturally you will need to install Erlang on your system. You may remember my previous article post about <a href="http://geekhmer.github.io/blog/2015/01/14/install-erlang-using-repository-on-ubuntu/">Install Erlang Using Repository on Ubuntu</a>.
</p>




<p>
  <strong>Download a Chicago Boss</strong><br/>
  Download the Chicago Boss source code from here: <a href="http://www.chicagoboss.org/" target="_blank">http://www.chicagoboss.org</a>.
</p>




<p>
  <strong>Open the Archive</strong><br/>
</p>


<p>{% codeblock lang:ruby %}
tar xzf ChicagoBoss-<em>.</em>.*.tar.gz
{% endcodeblock %}</p>

<p>
  <strong>Compile the Code</strong><br/>
</p>


<p>{% codeblock lang:ruby %}
cd ChicagoBoss-<em>.</em>.*
make
{% endcodeblock %}</p>

<p>
  <strong>Create a New Project</strong><br/>
</p>


<p>{% codeblock lang:ruby %}
make app PROJECT=project_name
{% endcodeblock %}</p>

<p>
  <strong>Enter the New Project Dir and Run the Development Server</strong><br/>
</p>


<p>{% codeblock lang:ruby %}
cd ../project_name
./init-dev.sh
{% endcodeblock %}</p>

<p>
  <strong>Enjoya</strong><br/>
  Point your browser to http://localhost:8001<br/>
  If all is well you will see a forbidding error message about the requested template — not to worry, the new project is empty so there is nothing to serve.
</p>




<p>
  So far so good, see you in the next articles. :)
</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Erlang Message Passing]]></title>
    <link href="http://geekhmer.github.io/blog/2015/01/27/erlang-message-passing/"/>
    <updated>2015-01-27T23:07:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/01/27/erlang-message-passing</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/logo_erlang.png" alt="Erlang Message Passing" />
</p>




<p>
  The communication model (among processes) in Erlang is message passing. Erlang processes share no memory. The way that processes communicate is via (asynchronous) message passing. Every process (even the shell) holds a mailbox queue where incoming messages are placed until received by the process. Message passing is asynchronous because the sending process does not block on send. On the other hand, receiving a message in Erlang is a blocking operation.
</p>




<p>
  <h3>Characteristics</h3>
</p>




<p>
  In this subsection I will describe some of the characteristics of message passing in Erlang.
</p>




<p>
  <strong>Asynchronous</strong><br/>
  Message passing in Erlang is a non-blocking operation.
</p>




<p>
  <strong>Data Copy</strong><br/>
  The message’s data are copied from the sending process to the receiver’s message queue, so the receiver gets a fresh copy of the data.
</p>




<p>
  <strong>Ordering</strong><br/>
  Erlang runtime guarantees that if two messages are sent from node A to node B and both are delivered, then the ordering of these messages is kept (because ordering).
</p>




<p>
  <strong>Successful Send</strong><br/>
  The send operation always succeeds (even if the target is a non-existing process) and evaluates to the data sent. An exception is when trying to send data to a non-existing registered process.
</p>




<p>
  <h3>Sending Messages</h3>
</p>




<p>
  Erlang uses the exclamation mark (!) as the operator for sending a message.
</p>




<p>
  Syntax:
</p>


<p>{% codeblock lang:ruby %}
%send message Message to the process with pid Pid
Pid ! Message
{% endcodeblock %}</p>

<p>
  Send multiple messages "at once":
</p>


<p>{% codeblock lang:ruby %}
Pid1 ! Message, Pid2 ! Message, Pid3 ! Message
Pid1 ! (Pid2 ! (Pid3 ! Message))
Pid1 ! Pid2 ! Pid3 ! Message
{% endcodeblock %}</p>

<p>
  Example:
</p>




<p>
  As I have mentioned before, the shell is nothing more than a process. As a process, it has a message queue. In order to print and empty the shell’s message queue we can use the flush/0 BIFs.
</p>


<p>{% codeblock lang:ruby %}
1> self() ! erlang_term_can_be_sent.
erlang_term_can_be_sent
2> flush().                           <br/>
Shell got erlang_term_can_be_sent
ok
3> self() ! [this, is, a, list, &lsquo;of&rsquo;, atoms].
[this,is,a,list,&lsquo;of&rsquo;,atoms]
4> self() ! {this, [is, a], tuple, {&lsquo;!&rsquo;, &lsquo;!&rsquo;}}.
{this,[is,a],tuple,{&lsquo;!&rsquo;,&lsquo;!&rsquo;}}
5> self() ! {self(), 123}.
{&lt;0.35.0>,123}
6> flush().
Shell got [this,is,a,list,&lsquo;of&rsquo;,atoms]
Shell got {this,[is,a],tuple,{&lsquo;!&rsquo;,&lsquo;!&rsquo;}}
Shell got {&lt;0.35.0>,123}
ok
7> Pid1 = self(), Pid2 = self(), Pid3 = self().
&lt;0.35.0>
8> Pid1 ! msg, Pid2 ! msg, Pid3 ! msg.
msg
9> flush().
Shell got msg
Shell got msg
Shell got msg
ok
10> Pid1 ! (Pid2 ! (Pid3 ! msg)).    <br/>
msg
11> flush().                   <br/>
Shell got msg
Shell got msg
Shell got msg
ok
12> Pid1 ! Pid2 ! Pid3 ! msg.  <br/>
msg
13> flush().               <br/>
Shell got msg
Shell got msg
Shell got msg
ok
{% endcodeblock %}</p>

<p>
  <h3>Receiving Messages</h3>
</p>




<p>
  Erlang uses pattern matching for receiving messages (same as in function clause selection and the case statement). The receive statement is used to deliver messages from the message queue.
</p>




<p>
  Syntax:
</p>


<p>{% codeblock lang:ruby %}
receive
  Pattern1 when Guard1 &ndash;></p>

<pre><code>ToDo1;
</code></pre>

<p>  Pattern2 when Guard2 &ndash;></p>

<pre><code>ToDo2;
</code></pre>

<p>  _Other &ndash;></p>

<pre><code>Catch_all
</code></pre>

<p>end
{% endcodeblock %}</p>

<p>
  <strong>Receiving Order</strong><br/>
  The message processing is done in a FIFS (First In – First Served) order. Every incoming message is placed in the tail of the process’ message queue. When a receive statement is meet the following processing happens:<br/>
  1. The first message (head of the message queue) is pattern matched against the first receive clause. If match, execute the clause’s body, else go to the next step.<br/>
  2. The same message is pattern matched against the second (if any) receive clause. If match, execute the clause’s body, else go to the next step.<br/>
  3. ...
  4. The same message is pattern matched against the last clause. If match, execute the clause’s body, else go to the next step.
  5. The same iterative process starts again from step 1, but now with the next message from the message queue.<br/><br/>
  The message (if any) that is delivered through receive is removed from the message queue.
</p>




<p>
  Example:
</p>


<p>{% codeblock pingpong.erl lang:ruby %}
-module(pingpong).
-export([play/1]).</p>

<p>play(N) when is_integer(N), N > 0 &ndash;>
  Pong = spawn(fun pong/0),
  ping(N, Pong).</p>

<p>ping(0,Pong) &ndash;>
  Pong ! exit,
  ok;
ping(N, Pong) &ndash;>
  Pong ! {self(), ping},
  receive</p>

<pre><code>pong -&gt;
  io:format("~w : pong [~w]~n", [self(), N])
</code></pre>

<p>  end,
  ping(N &ndash; 1, Pong).</p>

<p>pong() &ndash;>
  receive</p>

<pre><code>{From, ping} -&gt;
  io:format("~w : ping~n", [self()]),
  From ! pong,
  pong();
exit -&gt;
  ok
</code></pre>

<p>  end.
{% endcodeblock %}</p>

<p>
  Example running:
</p>


<p>{% codeblock lang:ruby %}
1> c(pingpong).
{ok,pingpong}
2> pingpong:play(4).
&lt;0.49.0> : ping
&lt;0.39.0> : pong [4]
&lt;0.49.0> : ping
&lt;0.39.0> : pong [3]
&lt;0.49.0> : ping
&lt;0.39.0> : pong [2]
&lt;0.49.0> : ping
&lt;0.39.0> : pong [1]
ok
{% endcodeblock %}</p>

<p>
  <strong>Timeout</strong><br/>
  Receive is a blocking statement; it blocks until a message that matches one of the clauses is placed in the incoming message queue. Erlang allows the programmer to explicitly unblock the receive statement using a timeout (if a matching message is not delivered until the timeout expires). The complete format of receive statement, including the after construct.
</p>




<p>
  Syntax:
</p>


<p>{% codeblock lang:ruby %}
receive
  Pattern1 when Guard1 &ndash;></p>

<pre><code>ToDo1;
</code></pre>

<p>  Pattern2 when Guard2 &ndash;></p>

<pre><code>ToDo2;
</code></pre>

<p>  _Other &ndash;></p>

<pre><code>Catch_all
</code></pre>

<p>after Millisecs &ndash;>
  ToDo_timeout;
end
{% endcodeblock %}</p>

<p>
  Example:
</p>


<p>{% codeblock timeout.erl lang:ruby %}
-module(timeout).
-export([start/0, sleep/1]).</p>

<p>start() &ndash;>
  spawn(fun timeout/0).</p>

<p>timeout() &ndash;>
  receive</p>

<pre><code>cancel -&gt;
  io:format("Timeout canceled~n")
</code></pre>

<p>  after 2000 &ndash;> % 2 seconds</p>

<pre><code>io:format("Timeout triggered~n"),
timeout()
</code></pre>

<p>  end.</p>

<p>%a sleep function
sleep(Ms) &ndash;>  <br/>
  io:format(&ldquo;Sleeping for ~w ms~n&rdquo;, [Ms]),
  receive
  after Ms &ndash;></p>

<pre><code>done
</code></pre>

<p>  end
{% endcodeblock %}</p>

<p>
  Example running:
</p>


<p>{% codeblock lang:ruby %}
1> c(timeout).
{ok,timeout}
2> P = timeout:start().
&lt;0.42.0>
Timeout triggered
Timeout triggered
3> P ! cancel.
Timeout canceled
cancel
4> timeout:sleep(1000).
Sleeping for 1000 ms
done
5> timeout:sleep(3000).
Sleeping for 3000 ms
done
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Erlang Concurrency]]></title>
    <link href="http://geekhmer.github.io/blog/2015/01/26/erlang-concurrency/"/>
    <updated>2015-01-26T18:46:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/01/26/erlang-concurrency</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/logo_erlang.png" alt="Erlang Concurrency" />
</p>




<p>
  Concurrency is defined as “the temporal property of two things happening at the same time”. In Computer Science, the definition is “concurrency is a property of systems in which several computations are executing simultaneously, and potentially interacting with each other. The computations may be executing on multiple cores in the same chip, preemptively time-shared threads on the same processor, or executed on physically separated processors.”
</p>




<p>
  Erlang was built with concurrency and fault-tolerance in mind.
</p>




<p>
  <h3>Processes</h3>
</p>




<p>
  The granularity of concurrency in Erlang is a process. A process is an activity/task that runs concurrently with and independently from the other processes (though processes can interact with each other using messages, links, etc.). Processes in Erlang are different than the processes and threads most people are familiar with. Erlang processes are lightweight, operate in (memory) isolation from other processes, and are scheduled by the Erlang’s Virtual Machine (VM). The creation time of process is very low, the memory footprint of a just spawned process is very small, and a single Erlang VM can have millions of processes running.
</p>




<p>
  <h3>Messaging Passing</h3>
</p>




<p>
  The communication model (among processes) in Erlang is message passing. Erlang processes share no memory. The way that processes communicate is via message passing (asynchronous). Every process (even the shell) holds a mailbox queue where incoming messages are placed until received by the process. Message passing is asynchronous because the sending process does not block on send. Sending a message in Erlang is a non-blocking operation that always succeed (more in the next post).
</p>




<p>
  <h3>Why Message Passing?</h3>
</p>




<p>
  We are so used to the shared memory model, why changing it? Here are some characteristics that are part of Erlang mostly because of the message passing memory model.
</p>




<p>
  <strong>Crash Independency</strong><br/>
  Message passing allows for easier distributed programming. Imagine if you want to distribute an application that uses shared memory. To do this, one should either use a message passing solution (such as MPI) or a Distributed Shared Memory system (DSM), that also uses message passing to operate. Why not using message passing in the first place? Especially in Erlang, message passing allows for location transparency (when sending a message there is no difference to the programmer if the receiver resides in the local or a remote node).
</p>




<p>
  <h3>Creating Processes</h3>
</p>




<p>
  Erlang provides Built-In Functions that are used to spawn new processes. The simplest one is spawn/1|3 (the 1|3 denotes that both spawn/1 and spawn/3 functions exist).
</p>




<p>
  <strong>Pid Datatype</strong><br/>
  Pid stands for Process identifier and is the datatype used for the unique process, identifiers that are assigned to every process.
</p>




<p>
  <strong>spawn/1|3</strong><br/>
  Creates a new process and returns its pid. The new process is placed in the system scheduler queue, so it will be run some time later.
</p>




<p>
  <strong>spawn/1</strong><br/>
  Called as spawn(Fun). The new process will run function Fun with an empty list ([]) as input.
</p>




<p>
  <strong>spawn/3</strong><br/>
  Called as spawn(Module, Function, Args). The new process will run function Module:Function with the elements of the list Args as input.
</p>




<p>
  Example:
</p>


<p>{% codeblock process.erl lang:ruby %}
-module(process).
-export([start/0, say_something/2]).</p>

<p>say_something(_What, 0) &ndash;> done;
say_something(What, Times) &ndash;>
  io:format(&ldquo;~p~n&rdquo;, [What]),
  say_something(What, Times &ndash; 1).</p>

<p>start() &ndash;>
  spawn(process, say_something, [&ldquo;hello&rdquo;, 3]),
  spawn(process, say_something, [&ldquo;bonjour&rdquo;, 2]).
{% endcodeblock %}</p>

<p>{% codeblock process1.erl lang:ruby %}
-module(process1).
-export([start/0, ping/2, pong/0]).</p>

<p>ping(0, Pong_Pid) &ndash;>
  Pong_Pid ! finished,
  io:format(&ldquo;ping finished~n&rdquo;, []);
ping(N, Pong_Pid) &ndash;>
  Pong_Pid ! {ping, self()},
  receive</p>

<pre><code>pong -&gt;
  io:format("ping received pong~n", [])
</code></pre>

<p>  end,
  ping(N &ndash; 1, Pong_Pid).</p>

<p>pong() &ndash;>
  receive</p>

<pre><code>finished -&gt;
  io:format("pong finished~n", []);
{ping, Ping_Pid} -&gt;
  io:format("pong received ping~n", []),
  Ping_Pid ! pong,
  pong()
</code></pre>

<p>  end.</p>

<p>start() &ndash;>
  Pong_Pid = spawn(message, pong, []),
  spawn(message, ping, [3, Pong_Pid]).
{% endcodeblock %}</p>

<p>
  <h3>Creating Linked Processes</h3>
</p>




<p>
  A very useful feature is to create a new process that is linked to the “parent” one. The link between them guarantees that if one of the two fails (finishes abnormally), the other one also stops executing. This feature is very helpful because it reduces the need for “cleaning up” in case of a failure. Instead of explicitely handling an error, the “let it fail and let someone else handle it” philosophy can be used. The BIF(s) providing this functionality are the spawn_link/1|3.
</p>




<p>
  <strong>link/1</strong><br/>
  Creates a bidirectional link between the calling process and another process (or port), if there is not such a link already. If a process attempts to create a link to itself, nothing is done. Returns true.
</p>




<p>
  <strong>spawn_link/1|3</strong><br/>
  Provides the same functionality as spawn/1|3 with the addition that a link is atomically created between the caller and the newly spawned process.
</p>




<p>
  <strong>spawn_link/1</strong><br/>
  Same call convention as spawn/1.
</p>




<p>
  <strong>spawn_link/3</strong><br/>
  Same call convention as spawn/3.
</p>




<p>
  Example:
</p>


<p>{% codeblock lang:ruby %}
spawnLink() &ndash;>
  spawn(fun spawnLink_/0).</p>

<p>spawnLink_() &ndash;>
  spawn_link(?MODULE, sayExit, []),
  justLoop().</p>

<p>justLoop() &ndash;>
  justLoop().</p>

<p>sayExit() &ndash;>
  timer:sleep(4000),
  erlang:kill(not_catched).</p>

<p>1> c(spawning).
{ok,spawning}
2> Pid = spawning:spawnLink().<br/>
&lt;0.42.0>
3> erlang:is_process_alive(Pid).
true
4> erlang:is_process_alive(Pid).
true
5> erlang:is_process_alive(Pid).
=ERROR REPORT==== 7-May-2011::12:24:54 ===
Error in process &lt;0.43.0> with exit value: {undef,[{erlang,kill,[not_
false
6> erlang:is_process_alive(Pid).
false
{% endcodeblock %}</p>

<p>
  <h3>Other Processes’-related Built-In Functions</h3>
</p>




<p>
  There are several other BIFs related to processes. The following are some commonly used.
</p>




<p>
  <strong>is_pid/1</strong><br/>
  Returns true if the argument is a pid, else false.
</p>


<p>{% codeblock lang:ruby %}
1> Pid = spawn(io, format, [&ldquo;Hello~n&rdquo;]).
Hello
&lt;0.37.0>
2> is_pid(Pid).
true
{% endcodeblock %}</p>

<p>
  <strong>is_process_alive/1</strong><br/>
  Called as is_process_alive(Pid). Pid must refer to a process at the local node. Returns true if the process exists and is alive, that is not exiting and has not exited. Otherwise, returns false.
</p>


<p>{% codeblock lang:ruby %}
1> is_process_alive(self()).
true
{% endcodeblock %}</p>

<p>
  <strong>list_to_pid/1</strong><br/>
  Transforms the input string to a pid. This BIF is intended to be used for debugging and not in the application development.
</p>


<p>{% codeblock lang:ruby %}
1> Pid == list_to_pid(&ldquo;&lt;0.39.0>&rdquo;).
true
{% endcodeblock %}</p>

<p>
  <strong>pid_to_list/1</strong><br/>
  Returns the textual representation of a pid. This BIF is intended to be used for debugging only.
</p>


<p>{% codeblock lang:ruby %}
1> StringPid = pid_to_list(Pid).
&ldquo;&lt;0.37.0>&rdquo;
{% endcodeblock %}</p>

<p>
  <strong>register/2</strong><br/>
  Registers a process (or a port) with a name. This name can be later used to refer to the process.
</p>


<p>{% codeblock lang:ruby %}
1> ShellPid = self().
&lt;0.99.0>
2> register(shell, ShellPid).
true
{% endcodeblock %}</p>

<p>
  <strong>registered/0</strong><br/>
  Returns a list with the names of all registered processes.
</p>


<p>{% codeblock lang:ruby %}
1> registered().
[init,shell,error_logger,rex,kernel_sup,inet_db,
 global_name_server,file_server_2,code_server,
 erl_prim_loader,user_drv,standard_error_sup,
 application_controller,standard_error,kernel_safe_sup,user,
 global_group]
{% endcodeblock %}</p>

<p>
  <strong>self/0</strong><br/>
  One of the most commonly used BIF, returns the pid of the calling processes. As you will see in the next post (about messaging), self is used in almost every message send.
</p>


<p>{% codeblock lang:ruby %}
1> ShellPid = self().
&lt;0.44.0>
{% endcodeblock %}</p>

<p>
  <strong>erlang:send/2|3</strong><br/>
  Sends a message to a process. You will see message sending in detail in the next post.
</p>




<p>
  <strong>erlang:send_after/3</strong><br/>
  Sends a message after a given amount of time.
</p>




<p>
  <strong>unlink/1</strong><br/>
  Removes the link between two processes. Returns true even if there is no exist link.
</p>




<p>
  <strong>unregister/1</strong><br/>
  Called as unregister(Name). Removes the association between the Name and the process which it is associated with.
</p>


<p>{% codeblock lang:ruby %}
1> unregister(shell).
true
2> registered().
[init,error_logger,rex,kernel_sup,inet_db,
 global_name_server,file_server_2,code_server,
 erl_prim_loader,user_drv,standard_error_sup,
 application_controller,standard_error,kernel_safe_sup,user,
 global_group]
{% endcodeblock %}</p>

<p>
  <strong>whereis/1</strong><br/>
  Called as whereis(Name). Returns the pid of the process that is register with the name Name.
</p>


<p>{% codeblock lang:ruby %}
1> whereis(shell).
&lt;0.44.0>
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Erlang List Comprehension]]></title>
    <link href="http://geekhmer.github.io/blog/2015/01/24/erlang-list-comprehension/"/>
    <updated>2015-01-24T21:02:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/01/24/erlang-list-comprehension</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/logo_erlang.png" alt="Erlang List Comprehension" />
</p>




<p>
  <h3>Syntax:</h3>
</p>


<p>{% codeblock lang:ruby %}
[Expression || Generators1, Guards1, Generators2, &hellip;]
{% endcodeblock %}</p>

<p><p>
  <strong>Expression</strong><br/>
  The expression specifies the elements of the result. Example: <code>[I || &lt;&ndash; [1, 2, 3]]</code> returns the input list element as is.
</p></p>

<p><p>
  <strong>Generators</strong><br/>
  Generators create the data used in ther filter-map operations. A generator has the &ldquo;Pattern &lt;&ndash; Data&rdquo; format, where &ldquo;Data&rdquo; is a list or an expression that results to a list and Pattern is a pattern used to match with the elements of the list. This pattern can be used to disassembly elements. Example two valid generators are <code>I &lt;&ndash; lists:seq(1, 10)</code> and <code>{X, Y} &lt;&ndash; [{&lsquo;A&rsquo;, &lsquo;Excellent&rsquo;}, {&lsquo;B&rsquo;, &lsquo;Good&rsquo;}, {&lsquo;C&rsquo;, &lsquo;Fair&rsquo;}]</code>.
</p></p>

<p><p>
  <strong>Guards</strong><br/>
  Guards are expression that return either true or false, the same as the guards we have seen in the previous posts. They apply to the variables that are on the left of the guard and the ones that are accessible to the scope where the comprehension runs. Example: <code>I &lt;&ndash; [1, 2, 3, 4], I rem 1 == 0</code> is a valid generator.
</p></p>

<p><p>
  <h3>Example:</h3>
</p></p>

<p><p>
  I will show some examples that implements some list functions. The most of them already exists in the lists module as I did in the past, I will add these functions to the module called mylists.
</p></p>

<p><p>
  <strong>map/2</strong><br/>
  The results contains the elements of the input list after applied to the input function.
</p></p>

<p>{% codeblock lang:ruby %}
% Generator: the items of the list provided
% Guard: no guard expression, all items are kept
% Expression: the item from the generator after applied to the Function</p>

<p>map(Function, List) &ndash;>
  [Function(I) || I &lt;&ndash; List].</p>

<p>1> mylists:map(fun(I) &ndash;> 2 * I end, [1, 2, 3, 4, 5]).
[2,3,6,8,10]
{% endcodeblock %}</p>

<p><p>
  <strong>deleteall/2</strong><br/>
  Deletes all occurrences of an element from the list.
</p></p>

<p>{% codeblock lang:ruby %}
% Generator: the items of the list provided
% Guard: the item should not be equal (both value and type) with the Elem
% Expression: keep the elements of the list that &ldquo;pass&rdquo; the guard test, as they are</p>

<p>deleteall(Elem, List) &ndash;>
  [I || I &lt;&ndash; List, I =/= Elem].</p>

<p>1> mylists:deleteall(3, [1, 2, 3, 4, 3, 2, 1]).
[1,2,4,2,1]
{% endcodeblock %}</p>

<p><p>
  <strong>partition/2</strong><br/>
  Partition a list into two, according to if the elements satisfy or not a given predicate.
</p></p>

<p>{% codeblock lang:ruby %}
partition(Pred, List) &ndash;>
  {[I || I &lt;&ndash; List, Pred(I)], [I || I &lt;&ndash; List, not(Pred(I))]}.</p>

<p>% an alternative implementation
partition2(Pred, List) &ndash;></p>

<pre><code>Sat = filter(Pred, List),
{Sat, List -- Sat}.
</code></pre>

<p>1> mylists:partition(fun(I) &ndash;> is_atom(I) end, [1, a, 2, b, 3.0]).
{[a,b],[1,2,3.0]}
{% endcodeblock %}</p>

<p><p>
  <strong>replicated/2</strong><br/>
  Creates a list of Items of length Times.
</p></p>

<p>{% codeblock lang:ruby %}
% Generator: only used for fixing the length
% Expression: a fixed item</p>

<p>replicated(Item, Times) &ndash;>
  [Item || _ &lt;&ndash; lists:seq(1, Times)].</p>

<p>1> mylists:replicated(&lsquo;:&ndash;)&rsquo;, 10).
[&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;,&lsquo;:&ndash;)&rsquo;]
{% endcodeblock %}</p>

<p><p>
  <strong>replicate_items/2</strong><br/>
  Replicates each elements of the list Times times.
</p></p>

<p>{% codeblock lang:ruby %}
replicate_items(Times, List) &ndash;>
  mylists:flatten([[Item || _ &lt;&ndash; lists:seq(1, Times)] || Item &lt;&ndash; List]).</p>

<p>% same as
% replicate_items(Times, List) &ndash;>
%   mylists:flatten([replicated(Item, Times) || Item &lt;&ndash; List]).</p>

<p>1> mylists:replicate_items(3, [a, b, c]).
[a,a,a,b,b,b,c,c,c]
{% endcodeblock %}</p>

<p><p>
  <strong>member/2</strong><br/>
  Returns true if an element is a member of the list, else returns false.
</p></p>

<p>{% codeblock lang:ruby %}
member(Elem, List) &ndash;>
  [] /= [ok || I &lt;&ndash; List, I == Elem].</p>

<p>1> mylists:member(a, [3, 2, 1, a, x, z]).
true
2> mylists:member(a, [3, 2, 1, aa, x, z]).
false
{% endcodeblock %}</p>

<p><p>
  <strong>member_times/2</strong><br/>
  Returns the number of occurences of an element in a list.
</p></p>

<p>{% codeblock lang:ruby %}
member_times(Elem, List) &ndash;>
  length([ok || I &lt;&ndash; List, I == Elem]).</p>

<p>1> mylists:member_times(a, [1, a, 2, 3, b, a, c]).
2
2> mylists:member_times(a, [1, a, 2, 3, b, c]). <br/>
1
3> mylists:member_times(a, [1, 2, 3, b, c]). <br/>
0
{% endcodeblock %}</p>

<p><p>
  <strong>quicksort/1</strong><br/>
  This is the famous Quicksort implementation that is often used to show the power and compactness of Erlang.
</p></p>

<p>{% codeblock lang:ruby %}
qsort([]) &ndash;>
  [];
qsort([Pivot | List]) &ndash;>
  qsort([I || I &lt;&ndash; List, I &lt; Pivot])
  ++
  [Pivot | qsort([I || I &lt;&ndash; List, I >= Pivot])].</p>

<p>1> mylists:qsort([7, 1, 3, 9, 1, 2, 0, 4, 6, 5]).
[0,1,1,2,3,4,5,6,7,9]
{% endcodeblock %}</p>

<p><p>
  <strong>Multiple Generators</strong><br/>
  Now I will present some examples with multiple generators.
</p></p>

<p>{% codeblock lang:ruby %}
1> [{I, J} || I &lt;&ndash; [1, 2, 3], J &lt;&ndash; [a, b, c]].
[{1,a},{1,b},{1,c},{2,a},{2,b},{2,c},{3,a},{3,b},{3,c}]</p>

<p>% duplicate list
2> [I || _ &lt;&ndash; [a, a], I &lt;&ndash; [1, 2, 3]].
[1,2,3,1,2,3]</p>

<p>% duplicate elements
3> [I || I &lt;&ndash; [1, 2, 3], J &lt;&ndash; [a, a]].
[1,1,2,2,3,3]</p>

<p>% discard elements and duplicate the others
4> Discard = [2, 4].
[2,4]
5> [I || I &lt;&ndash; [1, 2, 3, 4, 5, 6], not(lists:member(I, Discard)), _ &lt;&ndash; [a, a]].
[1,1,3,3,5,5,6,6]</p>

<p>% subsequences
8> [[I || I &lt;&ndash; lists:seq(1, J)] || J &lt;&ndash; lists:seq(1, 10)].
[[1],
 [1,2],
 [1,2,3],
 [1,2,3,4],
 [1,2,3,4,5],
 [1,2,3,4,5,6],
 [1,2,3,4,5,6,7],
 [1,2,3,4,5,6,7,8],
 [1,2,3,4,5,6,7,8,9],
 [1,2,3,4,5,6,7,8,9,10]]
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Erlang List &amp; List Module]]></title>
    <link href="http://geekhmer.github.io/blog/2015/01/22/erlang-list-and-list-module/"/>
    <updated>2015-01-22T23:01:00+07:00</updated>
    <id>http://geekhmer.github.io/blog/2015/01/22/erlang-list-and-list-module</id>
    <content type="html"><![CDATA[<p>
  <img src="http://geekhmer.github.io/images/logo_erlang.png" alt="Erlang Control Flow Statement" />
</p>




<p>
  List is the the most important data type in Erlang, as in every functional programming language. In this article, I will present the Erlang’s lists module and its most important functions.
</p>




<p>
  <h3>Syntax</h3>
</p>


<p>{% codeblock lang:ruby %}
[Element1, Element2, &hellip;, ElementN]
{% endcodeblock %}</p>

<p>
  N is called the length of the list. So, [] is the empty list.
</p>




<p>
  <h3>Decomposing & Pattern Matching</h3>
</p>




<p>
  An empty list pattern matches with [].
</p>


<p>{% codeblock lang:ruby %}
1> Empty = [].
[]
2> Empty == [].
true
3> Empty = [].
[]
4> NotEmpty = [1].
[1]
5> Empty == NotEmpty.
false
6> Empty = NotEmpty.
** exception error: no match of right hand side value [1]
{% endcodeblock %}</p>

<p>
  A non-empty list pattern matches with [Head | Tail].
</p>


<p>{% codeblock lang:ruby %}
1> [Head | Tail] = [1, 2, 3, 4].
[1,2,3,4]
2> Head.
1
3> Tail.
[2,3,4]
4> [Head1 | Tail1] = Tail.
[2,3,4]
5> Head1.
2
6> Tail1.
[3,4]
7> [Head2 | Tail2] = [].
** exception error: no match of right hand side value []
{% endcodeblock %}</p>

<p>
  <strong>Normal Representation</strong><br/>
  The format [Element1, Element2, ..., ElementN] is a shorthand of [Element1 | [Element2 | ... | [ElementN | []] ... ] representation.<br/>
  Example: the list [1, 2, 3] is a shorthand of [1 | [2 | 3 | []]], that is the normal representation of a list.
</p>




<p>
  Decomposing:
</p>


<p>{% codeblock lang:ruby %}
1> [A | [B |[C | D]]] = [1, 2, 3].
[1,2,3]
2> A.
1
3> B.
2
4> C.
3
5> D.
[]
{% endcodeblock %}</p>

<p>
  Composing:
</p>


<p>{% codeblock lang:ruby %}
1> List = [2,3].
[2,3]
2> List1 = [1 | List].
[1,2,3]
3> List2 = [-1 | [0 | List1]].
[-1,0,1,2,3]
4> List3 = [[-3, -2] | List2].
[[-3,-2],-1,0,1,2,3] % the head is just 1 element
{% endcodeblock %}</p>

<p>
  Of course, since it is more readable and easier to write, the shorthand representation is usually used: 
</p>


<p>{% codeblock lang:ruby %}
1> [A, B, C] = [1, 2, 3].
[1,2,3]
2> [A, B, C, D] = [1, 2, 3]. % does not match cause
% the left-hand side matches a 4-elements list
** exception error: no match of right hand side value [1,2,3]
3> [A, B, C | D] = [1, 2, 3].
[1,2,3]
4> D.
[]
5> [-3, -2 | [-1, 0 | [1 | [2,3]]]].<br/>
[-3,-2,-1,0,1,2,3]
{% endcodeblock %}</p>

<p>
  <strong>List Parsing</strong><br/>
  The pattern matching you saw before can be used in a function in order to parse the list:
</p>


<p>{% codeblock lang:ruby %}
parse([]) &ndash;>
  parsed.
parse([Head | Tail]) &ndash;>
  parse(Tail).
{% endcodeblock %}</p>

<p>
  <strong>Concatenation</strong><br/>
  Two lists can be concatenated using ++:
</p>


<p>{% codeblock lang:ruby %}
1> L1 = [1, 2], L2 = [3, 4, 5].
[3,4,5]
2> L1 ++ L2.
[1,2,3,4,5]
3> L1 ++ L2 ++ L1.
[1,2,3,4,5,1,2]
4> Mirror = fun(List) &ndash;> List ++ lists:reverse(List) end.</p>

<h1>Fun&lt;erl_eval .6.13229925></h1>

<p>5> Mirror([a, b, {c}]).
[a,b,{c},{c},b,a]
{% endcodeblock %}</p>

<p>
  <strong>Difference</strong><br/>
  You can take the difference of two lists (the left-hand side one without the element of the right-hand side) using the -- operator:
</p>


<p>{% codeblock lang:ruby %}
1> [1, 2, 3] &mdash; [1, 2, 3].
[]
2> [1, 2, 3] &mdash; [1, 3]. <br/>
[2]
3> [1, 2, 3] &mdash; [1, 3, 3].
[2]
4> [1, 3, 2, 3] &mdash; [1, 3, 3].
[2]
5> [3, 1, 3, 2, 3] &mdash; [1, 3, 3].
[2,3]
6> [1, 2, 3] &mdash; [a, b].       <br/>
[1,2,3]
7> Delete = fun(List, Element) &ndash;> List &mdash; [Element] end.</p>

<h1>Fun&lt;erl_eval .12.113037538></h1>

<p>8> Delete([1,2,3,4,1], 1).
[2,3,4,1]
{% endcodeblock %}</p>

<p>
  <h3>Module Lists</h3>
</p>




<p>
  The lists module defines some commonly used list processing functions. This module is extremely useful, so it is a good idea to “remember” what functions it provides.
</p>




<p>
  <strong>all/2</strong><br/>
  Called as all(Pred, List). Returns true if Pred(Element) returns true for all lists’ elements.
</p>


<p>{% codeblock lang:ruby %}
1> L = [2, 4, 6, 8],
1> F = fun(X) &ndash;> X rem 2 == 0 end,
1> lists:all(F, L).
true
2> f().
ok
3> L = [2, 4, 5, 8],
3> F = fun(X) &ndash;> X rem 2 == 0 end,
3> lists:all(F, L).
false
{% endcodeblock %}</p>

<p>
  <strong>append/1|2</strong><br/>
  Concatenates the lists to one.
</p>


<p>{% codeblock lang:ruby %}
1> lists:append([[1, 2], [3], [4, 5]]).
[1,2,3,4,5]
2> lists:append([1, 2], [3, 4]).
[1,2,3,4]
{% endcodeblock %}</p>

<p>
  Notice that the operator ++ and the function append/2 are the same.
</p>




<p>
  <strong>delete/2</strong><br/>
  Deletes an element from the list (first occurrence, if any).
</p>


<p>{% codeblock lang:ruby %}
1> lists:delete(a, [d, a, d, a, d]).
[d,d,a,d]
{% endcodeblock %}</p>

<p>
  <strong>concat/1</strong><br/>
  Accepts a list of items (atom, integer, float, string) and returns the concatenation of their textual representation as a list.
</p>


<p>{% codeblock lang:ruby %}
1> lists:concat([&ldquo;ab&rdquo;, &lsquo;.&rsquo;, 1]).   <br/>
&ldquo;ab.1&rdquo;
{% endcodeblock %}</p>

<p>
  <strong>filter/2</strong><br/>
  Called as filter(Pred, List). Returns a list containing only the elements that return true for the Pred.
</p>


<p>{% codeblock lang:ruby %}
1> Gt10 = fun(X) &ndash;> X > 10 end, lists:filter(Gt10, [1, 2, 22, 3, 44, 5, 66]).
[22,44,66]
2> L = [1, a, b, 2, c, 3.0, d, {4}].
[1,a,b,2,c,3.0,d,{4}]
3> lists:filter(fun(X) &ndash;> is_number(X) end, L).
[1,2,3.0]
{% endcodeblock %}</p>

<p>
  <strong>flatten/1</strong><br/>
  Returns a flattened (no element is a list) version of the input list.
</p>


<p>{% codeblock lang:ruby %}
1> lists:flatten([1, [2], [3, 4, [5, [6, 7]]], [[[[8]]]]]).
[1,2,3,4,5,6,7,8]
{% endcodeblock %}</p>

<p>
  <strong>key*** functions</strong><br/>
  There are several functions which their name starts with the word "key". They are all used to process lists of tuples.
</p>


<p>{% codeblock lang:ruby %}
1> Kl = [{a, k1, a}, {b, k2, b}, {c, k3, c}, {e, k5, e}].
[{a,k1,a},{b,k2,b},{c,k3,c},{e,k5,e}]
2> lists:keydelete(k3, 2, Kl).
[{a,k1,a},{b,k2,b},{e,k5,e}]
3> lists:keysearch(k3, 2, Kl).
{value,{c,k3,c}}
4> lists:keysearch(k4, 2, Kl).
false
5> lists:keyreplace(k3, 2, Kl, {new, tuple}).
[{a,k1,a},{b,k2,b},{new,tuple},{e,k5,e}]
{% endcodeblock %}</p>

<p>
  <strong>last/1</strong><br/>
  Returns the last element of the list.
</p>


<p>{% codeblock lang:ruby %}
1> lists:last([1, 2, 3]).
3
{% endcodeblock %}</p>

<p>
  <strong>map/2</strong><br/>
  Called as map(Fun, List). Applies function Fun to every item of the list and returns the resulting list.
</p>


<p>{% codeblock lang:ruby %}
1> lists:map(fun(I) &ndash;> 2 * I end, [1, 2, 3]).
[2,4,6]
{% endcodeblock %}</p>

<p>
  <strong>partition/2</strong><br/>
  Partitions a list to two according to if the elements satisfy or not a given predicate.
</p>


<p>{% codeblock lang:ruby %}
1> lists:map(fun(I) &ndash;> 2 * I end, [1, 2, 3]).
[2,4,6]
{% endcodeblock %}</p>

<p>
  <strong>reverse/1|2</strong><br/>
  Returns the reverse of a list.
</p>


<p>{% codeblock lang:ruby %}
1> lists:reverse([a, b, c, d]).
[d,c,b,a]
2> lists:reverse([a, b, c, d], [1, 2, 3]).
[d,c,b,a,1,2,3]
{% endcodeblock %}</p>

<p>
  <strong>sort/1|2</strong><br/>
  Sorts a list to increasing order or according to a given function.
</p>


<p>{% codeblock lang:ruby %}
1> L = [3, 1, 2, 5, 4].
[3,1,2,5,4]
2> lists:sort(L).
[1,2,3,4,5]
3> Gt = fun(I, J) &ndash;> I > J end.</p>

<h1>Fun&lt;erl_eval .12.113037538></h1>

<p>4> lists:sort(Gt, L).
[5,4,3,2,1]
{% endcodeblock %}</p>

<p>
  <strong>sum/1</strong><br/>
  Returns the sum of the elements of a list containing numbers.
</p>


<p>{% codeblock lang:ruby %}
1> lists:sum([1, 2.2, 3]).
6.2
{% endcodeblock %}</p>

<p>
  <strong>u*** functions</strong><br/>
  There are several function which their name starts with "u" and the results they return contain no duplicates.
</p>


<p>{% codeblock lang:ruby %}
1> lists:usort([5, 3, 2, 3, 2, 1, 4, 5]).
[1,2,3,4,5]
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
